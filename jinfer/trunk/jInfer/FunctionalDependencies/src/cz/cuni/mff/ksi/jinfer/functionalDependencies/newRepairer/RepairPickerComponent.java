/*
 * Copyright (C) 2011 sviro
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package cz.cuni.mff.ksi.jinfer.functionalDependencies.newRepairer;

import cz.cuni.mff.ksi.jinfer.base.automaton.Automaton;
import cz.cuni.mff.ksi.jinfer.functionalDependencies.repairer.Repair;
import java.util.List;
import javax.swing.tree.DefaultTreeModel;

/**
 *
 * @author sviro
 */
public class RepairPickerComponent extends javax.swing.JPanel {

  private static final long serialVersionUID = 764324657L;
  private final Object monitor;
  private boolean interrupted = false;
  private RepairGroupModel model;

  /** Creates new form NewJPanel */
  public RepairPickerComponent() {
    super();
    monitor = new Object();
    initComponents();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;

    repairTreePane = new javax.swing.JSplitPane();
    jScrollPane1 = new javax.swing.JScrollPane();
    repairTree = new javax.swing.JTree();
    jScrollPane2 = new javax.swing.JScrollPane();
    jPanel1 = new javax.swing.JPanel();
    jLabel1 = new javax.swing.JLabel();
    jButton1 = new javax.swing.JButton();

    setLayout(new java.awt.GridBagLayout());

    repairTreePane.setDividerLocation(200);

    repairTree.setRootVisible(false);
    jScrollPane1.setViewportView(repairTree);

    repairTreePane.setLeftComponent(jScrollPane1);

    jLabel1.setText(org.openide.util.NbBundle.getMessage(RepairPickerComponent.class, "RepairPickerComponent.jLabel1.text")); // NOI18N
    jPanel1.add(jLabel1);

    jScrollPane2.setViewportView(jPanel1);

    repairTreePane.setRightComponent(jScrollPane2);

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 1.0;
    add(repairTreePane, gridBagConstraints);

    jButton1.setText(org.openide.util.NbBundle.getMessage(RepairPickerComponent.class, "RepairPickerComponent.jButton1.text")); // NOI18N
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
    gridBagConstraints.insets = new java.awt.Insets(2, 12, 2, 12);
    add(jButton1, gridBagConstraints);
  }// </editor-fold>//GEN-END:initComponents
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton jButton1;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JPanel jPanel1;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JScrollPane jScrollPane2;
  private javax.swing.JTree repairTree;
  private javax.swing.JSplitPane repairTreePane;
  // End of variables declaration//GEN-END:variables

  /**
   * Thread that calls this method is suspended until method <code>guiDone()</code>
   * is called on this instance. Used to wait for user interaction when
   * {@link Automaton} is shown in AutoEditor.
   * @throws InterruptedException
   */
  public void waitForGuiDone() throws InterruptedException {
    synchronized (monitor) {
      monitor.wait();
    }
  }

  /**
   * Call to wake up all threads that are suspended in call of method
   * <code>waitForGUIDone()</code> on this instance.
   */
  public void guiDone() {
    synchronized (monitor) {
      monitor.notifyAll();
    }
  }

  /**
   * Signals AutoEditor that waiting for any user interaction (on this instance)
   * has to be interrupted and inference has to interrupted as well.
   */
  public void guiInterrupt() {
    interrupted = true;
    guiDone();
  }

  /**
   * Checks if <code>guiInterrupt()</code> was called on this instance.
   */
  public boolean guiInterrupted() {
    return interrupted;
  }

  public Repair getPickedRepair() {
    throw new UnsupportedOperationException("Not yet implemented");
  }

  public void setModel(final List<RepairGroup> repairGroups) {
    model = new RepairGroupModel(repairGroups);
    repairTree.setModel(new DefaultTreeModel(model.getTree()));
  }
}
