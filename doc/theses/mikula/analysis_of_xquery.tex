\chapter{Analysis of XQuery}
\todo[inline]{bibref na knihu, a W3C XQuery usecases}
This chapter discusses selected constructs of XQuery language and denotes how they could be exploited in the XML schema inference process. It is divided into sections by particular domains of the inference.

\section{Structure of XML documents}
The most queries can be exploited to obtain some information about a structure of respective XML documents. The structure of XML documents captures elements from these documents along with their names, attributes and their organization. What are the outermost elements in these document, which elements can be contained inside a certain element, whether are they optional or mandatory, etc.

Path expressions without predicates which use only child axis are the simpliest example of such queries. Path expression \texttt{/bib/book/author} indicates element \texttt{bib} is the outermost element and contains one or more elements \texttt{book} and these contains one or more elements \texttt{author}.

Additional path expressions \texttt{/bib/book/title}, \texttt{//author/name} indicate that element \texttt{book} also contains element \texttt{title} and element \texttt{author} contains element \texttt{name}. The latter one uses also descendant axis.

Besides elements, attributes could be processed exactly the same way. Path expression \texttt{/bib/book/@ISBN} indicates that element \texttt{book} has attribute \texttt{@ISBN}.

However statemets of this kind are necessary for the XML schema inference, their obtaining from queries it not significant because of the following reason. These statement could be determined directly from the XML documents and it could be easily done in a more convenient way. Queries may not cover the whole relevant content of the documents. For example some element may not be queried at all, therefore they mat not be mentioned in any query. In addition, these statements do not express any obligation of occurrence of elements and attributes or possible multiple occurence of elements. At last, we cannot be sure that queries target nodes actually presented in the XML documents. Although query \texttt{/bib/book/author} indicates that element \texttt{author} is contained in element \texttt{book}, the query is valid whether this is true or not. In opposite, even basic methods of XML documents analyzis do not have these inadequacies.

On the other hand, the structure inference could be useful when the whole set of all XML documents is not available and provided XML documents do not cover the structure completly.

\section{Occurrence Count of Elements}
Some XQuery constructs indicate multiplicity of a particular element or limit the element to occur at most once. Consider the following query assuming variable \texttt{\$book1} is bound to a certain \texttt{book} element.

\begin{verbatim}
for $a in $book1/author 
order by $a/last, $a/first
return $a
\end{verbatim}

Apparently, this query expects more than one element \texttt{author} to be children of the element variable \texttt{\$book1} is bound to. Otherwise, any sorting would lack a reason. Although, we cannot be absolutely sure about it again, assuming common sense usage of XQuery it is very likely that element \texttt{author} can occur multiple times as a subelement of element from variable \texttt{\$book1}.

\subsection{Multiple Occurrence}
Similar approach could be applied in many other situations. Another examples are particular usages of function \texttt{count()}, indexation, usage of set operators (\texttt{union}, \texttt{intersect}, \texttt{except}) and usage of function \texttt{one-or-more()}. Queries with description follows.

\begin{verbatim}
<section_count>{ count(/book/section) }</section_count>
\end{verbatim}

Function \texttt{count()} returns number of items in a provided sequence. If the sequence is sequence of elements the count of these elements will probably not be limited to one. The example query indicates that the outermost element \texttt{book} can contain more than one element \texttt{section}.
An exception is usage of function \texttt{count()} in a predicate in expressions where it is used to determine if count of some nodes is greater than zero. Often, this form is used to test presence of a certain node instead of actual counting of its occurrences. In this case, the node could be still limited to occur at most once.

\begin{verbatim}
($s/incision)[2]/instrument
($s/instrument)[position()>=2]
\end{verbatim}

Indexation of nodes and common usage of function \texttt{position()} suggest that writer of such query assumes sequence of respective nodes.

\begin{verbatim}
one-or-more(/catalog/product[@id = 5]/color)
\end{verbatim}

In this query, number of elements \texttt{color} in element \texttt{product} with attribute \texttt{id} equal to 5 has to be at least one otherwise an error is raised upon execution. If we assume that this query is written correctly, with common sense and should not raise the error, we can infer that element \texttt{product} has to containt one or more elements \texttt{color}

\subsection{Occurrence Limited to One}
In opposite to the multiple occurrence, numerous XQuery constructs limit number of occurrences of an element to at most one or exactly one. Some example queries with description follow.

\begin{verbatim}
/catalog/product[1]/number lt 10
\end{verbatim}

\texttt{lt} is a representant of so called \emph{value comparison operators} which operate two sequences of zero or one item. If an operand of a \emph{value comparison operand} is sequence of more than one item \emph{type error} is raised.

\begin{verbatim}
for $item in //item 
order by $item/num 
return $item
\end{verbatim}

Alike the previous example, expression in \texttt{order by} clause can be evaluated to at most one item or the \emph{type error} is raised. Therefore, every element \texttt{item} contains zero or one element \texttt{num} but no more.

Another similar examples are arithmetic expressions and functions accepting a sequence of at most one item. Functions \texttt{zero-or-one()} will raise the \emph{type error} when supplied with an sequence of more than one item.

Those are constructs indicating limitation to zero or one occurrence. Function \texttt{exactly-one} works similar to the function \texttt{zero-or-one} but accepts only sequences of exactly one item (which are in XQuery equal to this item itself).

\section{Element and Attribute Types}

\subsection{XML Schema Built-in Types}
XML Schema built-in types of elements and attributes can be inferred from the XML documents by analysing their content. Since the count of built-in types is 44 and inheritance is involved, such analysis may be imprecise especially when a large enough set of XML documents is not available. \todo[inline]{priklad?} This is when a set of XQuery queries may be handy.

If a value of an element or attribute is used in an expression then this expression could be often exploited to determine a type of the value. Comparing the value to another value of a known type and supplying the value to a function call as an argument of particular type are examples of these expressions as shown below.

\begin{verbatim}
\\event\date = current-date()

\catalog\product\price < 24.5

declare function local:byteFunction($arg as xs:byte) as xs:byte
{...};
\catalog\product\local:byteFunction(@id)
\end{verbatim}
\todo[inline]{overit, ci su priklady OK}

Determined types are \texttt{xs:date} for element \texttt{date}, \texttt{xs:decimal} for element \texttt{price} and \texttt{xs:byte} for attribute \texttt{id}.

Alongside common expressions, there are other XQuery constructs indicating types as \emph{type casting}, \emph{constructors} and so called \emph{type declarations}.

Assuming variable \texttt{\$var} bound to a value of some element or attribute, following two fractions of queries indicate its type to be \emph{xs:integer}.

\begin{verbatim}
$var cast as xs:integer
xs:integer($var)
\end{verbatim}

The latter one is usage of \emph{type casting}, the former one is \emph{type constructor}.

Alike, following two examples of \emph{type declarations}. Value of element \texttt{number} is declared to be of type \texttt{xs:integer}.

\begin{verbatim}
every $number as element(*,xs:integer) in //number satisfies ($number > 0) 

declare variable $firstNumber as xs:integer 
:= data(//product/number[1]); 
\end{verbatim}

Although, determining built-in types of elements and attributes in simple queries may seem quite straightforward, reliable method would face some issues. More complex queries are commonly branched by \emph{if-then-else} construct. These branches can contain several contradictionary fragments from the view of type inference. Therefore, the reliable method would take the query structure into consideration and futher research would be needed.

\subsection{Enumeration}
In several cases, XQuery \emph{if-then-else} construct may be used to branch the execution of query by all posible values of a certain variable. This is equivalent of \emph{switch} construct from other programming languages. When the control variable is bound to some element or attribute, type of this node can be inferred as enumeration and its individual values can be determined as well.

\begin{verbatim}
Query
let $cat := doc("catalog.xml")/catalog 
for $dept in distinct-values($cat/product/@dept) 
return <li>Department: {if ($dept = "ACC") 
                        then "Accessories" 
                        else if ($dept = "MEN") 
                             then "Menswear" 
                             else if ($dept = "WMN") 
                                  then "Womens" 
                                  else () 
  } ({$dept})</li> 

Results 
<li>Department: Womens (WMN)</li> 
<li>Department: Accessories (ACC)</li> 
<li>Department: Menswear (MEN)</li> 
\end{verbatim}

Finding such patterns in queries could be useful in combination with analysis of XML data this queries are executed upon. XML data could help to confirm or disprove this assumption based on the query analysis or vice-versa.

\section{Keys}

\subsection{Approach from Paper Discovering XML Keys and Foreign Keys in Queries}
Paper \todo{link} introduces a method of discovering keys and foreign keys by investigation of joins in queries. Basis of this discovery is a search for particular forms of joins, so called \emph{join patterns} \todo{uviest ich sem?}, but the joins are processed only if they are found in a particular syntactic form. Therefore joins with the same semantics written in different syntax are not taken into consideration.

The following examples are queries that could be processed by a similar method but the actual method will not use them.

\begin{verbatim}
<result>
  {
    for $u in doc("users.xml")//user_tuple
    for $i in doc("items.xml")//item_tuple
    where $u/rating > "C" 
       and $i/reserve_price > 1000 
       and $i/offered_by = $u/userid
    return
        <warning>
            { $u/name }
            { $u/rating }
            { $i/description }
            { $i/reserve_price }
        </warning>
  }
</result>
\end{verbatim}

Clause \texttt{where} is used for the join condition \texttt{\$i/offered\_by = \$u/userid instead} of the join condition in predicate of the second \texttt{for} expression.

\begin{verbatim}
<result>
  {
    for $i in doc("items.xml")//item_tuple
    where empty(doc("bids.xml")//bid_tuple[itemno = $i/itemno])
    return
        <no_bid_item>
            { $i/itemno }
            { $i/description }
        </no_bid_item>
  }
</result>
\end{verbatim}

This query illustrates a join where the value of one of the joined elements is not required, the knowledge of its existence is sufficient. Therefore the query has not to contain the second \texttt{for} or \texttt{let} keyword and its expression can be moved to \texttt{where} clause.

\begin{verbatim}
for $item in doc("order.xml")//item, 
    $product in doc("catalog.xml")//product, 
    $price in doc("prices.xml")//prices/priceList/prod 
where $item/@num = $product/number and $product/number = $price/@num 
return <item num="{$item/@num}" 
         name="{$product/name}" 
         price="{$price/price}"/>
\end{verbatim}

A common three-way join.

\subsection{Join of Recursive Data}
By the term "recursive data" are meant XML data, for example elements, that somehow reference items from the same set. Example of query that operates upon such data follows.

\begin{verbatim}
declare function local:one_level($p as element()) as element()
{
  <part partid="{ $p/@partid }" name="{ $p/@name }" >
    {
      for $s in doc("partlist.xml")//part
      where $s/@partof = $p/@partid
      return local:one_level($s)
    }
  </part>
};

<parttree>
  {
    for $p in doc("partlist.xml")//part[empty(@partof)]
    return local:one_level($p)
  }
</parttree>
\end{verbatim}

Apparently, element \texttt{part} can contain attributes \texttt{partid} and \texttt{partof}. Elements with not specified attribute \texttt{partof} are at the top of the recursive hierarchy while in elements with this attribute specified it makes a reference to an element with attribute \texttt{partid} of the same value.

By using similar approach as described in the paper \todo{ref} attribute \texttt{partid} can be marked as a key and attribute \texttt{partof} as its foreign key.

\subsection{Negative Statements about Uniqueness}
In many cases it could be inferred a statement that refuses uniqueness of element's or attribute's values. Such statements may prove helpful in combination with other methods in its process of decision making whether a particular element or attribute is unique or not.

Basic representant is a common \emph{FLWOR} query.

\begin{verbatim}
<bib>
  {
    for $b in doc("http://bstore.example.com/bib.xml")//book
    where $b/publisher = "abcde" and $b/@year > 2000
    order by $b/title
    return
        <book>
            { $b/@year }
            { $b/title }
        </book>
  }
</bib>
\end{verbatim}

Usage of \texttt{for} construct indicates that it is expected a sequence of \texttt{book} elements which satisfy the condition if \emph{where} clause. It is a condition composed of two single conditions joined by \emph{and} logical operator. Therefore in order to satisfy the whole condition, both two single conditions must be satisfied as well. Thus, it is expected that several elements satisfy each of the single conditions.

The first of them is test of equality of book's subelement \texttt{publisher} to a string literal. Based on the expectation, element \texttt{publisher} cannot be unique. However, the second condition is greater-than comparison of \texttt{year} attribute to an integer literal, it cannot be inferred whether this attribute is unique or not. It is because even if it was unique there still might be more than one \texttt{book} element meeting this condition, thus the expectation was fullfiled too. Also, any statement, positive nor negative, cannot be inferred about \texttt{title} subelement.

Another simple examples are passing a result of basic path expression to a call of \texttt{distinct-values()} function and usage of \emph{aggregation} functions.

\begin{verbatim}
<results>
  {
    let $doc := doc("prices.xml")
    for $t in distinct-values($doc//book/title)
    let $p := $doc//book[title = $t]/price
    return
      <minprice title="{ $t }">
        <price>{ min($p) }</price>
      </minprice>
  }
</results>
\end{verbatim}

According to the use of \texttt{distinct-values()} function, it can be easily seen that writter of this query assumes possible occurrence of more than one \texttt{book} elements with the same value of their \texttt{title} subelement. Thus, \texttt{title} element is not unique.

Alike, variable \texttt{\$p} is bound to a price of each title and then passed to \texttt{min()} function call. That indicates that one book title is supposed to have several prices, however, it cannot be said if a certain occurrence of element \emph{book} can contain more than one \texttt{price} subelement.

Also, many other types of queries could be exploited to obtain negative uniqueness statemens like occurrence of element or attribute in \texttt{stable order by} clause or selection of an element set based on a value of particular attribute and consecutive treatment of this set as a sequence of elements.

\begin{verbatim}
let $prods := doc("catalog.xml")//product 
for $prod in $prods 
where $prod << $prods[@dept = $prod/@dept][last( )] 
return $prod 
\end{verbatim}

\subsection{Uniqueness}
TODO