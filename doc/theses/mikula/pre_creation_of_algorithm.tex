\chapter{Pre-creation of Algorithm}
According to the analysis in the previous chapter, there is quite a wide range of possible utilizations of XQuery queries. Besides analysis of what information can be extracted from queries, it is needed to devise how the queries will be processed. This chapter discusses some questions and issues that emerged in an early phase of the algorithm fabrication.

\section{Input Data}
The first important question is what is the input of the algorithm. A basic query utilization can be achieved by analysis of queries without any other input data. The analysis of XQuery in the previous chapter discusses mostly XQuery constructs which can be utilized without respective XML data, for example the inference of built-it types. This independence is also the main advantage of this approach, if there are no XML data available, this approaches can be still used. 

A more complex method can utilize queries along with the respective XML data. As discussed in the previous chapter, an element and attribute structure can be inferred from the XML data in a more convenient way. Also, the XML data can be used to verify information inferred from the queries or vice-versa. For example, utilizing the queries, some attribute is considered a key of its element. But in the data there are elements with the same value of this attribute, and thus, it cannot be the key. Vice-versa, we have a notion that the attribute might be the key but we are not sure about that. Analysing of the data and finding that values of the attribute are unique can increase our confidence. 

Another step can be evaluation of the queries using the XML data and consecutive analysis of the results. And even the process of evaluation itself can be analyzed to obtain some useful information. For instance, these are partial results of evaluating of expressions (elements selected by each path expression, real arguments in fuction calls, etc).

\todo[inline]{Dopisat, ako sme sa rozhodli - nejaky zaver. Este presne neviem, ale pravdepodobne prva faza bude spracovanie cisto queries a druha by mohla byt kontrola na zaklade XML dat. Na dalsie vstupne data asi nebude kapacita}

\todo[inline]{Určitě to chce kombinaci dotazů a dat. Na začátku textu říkáme, že samotné dotazy nestačí, resp. neříkají všechno. Ale klidně můžete v textu popsat oboje a pak implementovat jen část z obojího a porovnat výsledky. Nebo vzít nějakou metodu, která je v jInfer (DP p. Klempy), rozšířit ji o zpracování dotazů a na nějakých pěkných datech ukázat, že je to rychlejší/dává lepší (přesnější) výsledky.}

\section{Forms of Query Precessing}
Another important question is how the queries can be processed. Will they be just searched for certain patterns like it is performed in method \cite{Necasky:2009:DXK:1529282.1529414} or will they be processed in a more sophisticated way? That can mean incorporating lexical and syntax analyses, known from creation of compilers, or even a form of an analysis of semantics \cite{compilers}.

The result of lexical and syntax analyses can be a kind of so-called syntax tree \cite{compilers}. It is a structure representing a word according to a formal grammar of a language. In our case, the language is XQuery, its grammar is defined in REF \todo{ref} and every query is a word of the XQuery language. Leaves of the tree represent terminals of the grammar while inner nodes represent non-terminals. \todo{priklad nejakeho stromu?} From the point of view of this work, the syntax tree can be perceived as a preprocessed form of a query keeping its complete meaning and making its further processing more convenient. For instance, the tree can simplify a search for FLWOR statements. It is transitioned and nodes representing FLWORs are found. Then each subtree determined by one of the found nodes represents a FLWOR statement and it can be analyzed further.

\todo[inline]{Q: definovat grammar, tree, language? A: Pokud bude použito dále, tak ano.}

The syntax tree can be also extended by additional information. An example is a static analysis of expression types. Types of literal expressions are defined, functions have return types, path expressions can return nodes, etc. Types of complex expressions can be determined applying the rules defined in REF \todo{ref}. The inferred expression types can be helpful for example in the analysis of built-in types of nodes as discussed in the previous chapter. 

The following text is an example of inference of a more complex query processing. Consider the following part of a query.
\begin{verbatim}
declare function local:getB($id as xs:string) as element() {
  //A[@id = $id]/B
}
... local:getBs("id") > 10 ...
\end{verbatim}
The query consists of a function declaration and an arithmetic comparison. The comparison compares a result of the function call and literal value \texttt{10}. For the type of \texttt{10} is \texttt{xs:integer} the type of the function call has to be convertible to \texttt{xs:double}. Thus, it has to be a numeric type. The function returns a path expression typed as \texttt{element()}. That means the function returns one element \todo{pravda?}. In the path expression, the argument \texttt{\$id} can be substituted by the real value specified in the call. Thus, the return expression is \texttt{//A[@id = "id"]/B}. Therefore, we can infer that element \texttt{B} in element \texttt{A} with attribute \texttt{id} equaling string value \texttt{"id"} is of some numeric type. And, for the function is parametrized \todo{divná věta} there is a notion that this statement may be correct also for other elements \texttt{A} and \texttt{B}.

While simplier approaches of the query processing such as the pattern finding limit possibilities of the query utilization, a more complex processing of queries provides a better starting point for consecutive analyses and also for further refinements and additions. Therefore, we decided to incorporate query processing using the lexical and syntax analyses.

\section{Inference of XML Structure}
The question of inference of XML structure from queries is partially discussed in the previous chapter. We are able to infer XML structure from queries without their evaluation, but in a limited way. This inference is based on an analysis of path expressions. Its limitation involves the following issues. When we infer some subelements of a certain element we often cannot be sure about their number of occurrences. Also, we cannot be sure if every occurrence of a certain element contains the subelements and we even do not know if at least one occurrence of the element contains them. Thus, the inferred statement is more likely an indication than a fact about the structure.

\todo[inline]{S proč potřebuju vyhonotit dotazy? Dostanu nějaký výsledek, ale ten může obsahovat třeba úplně jiná data ne jsou v dokumentech - použiju konstruktory, něco sečtu a původní idokumenty můžou být úplně jiné.}

If we want to infer the structure more precisely we need to evaluate the queries, and thus, we need the XML data to evaluate the queries upon. But, if we have the XML data, we can infer the structure directly from them in an easier and more convenient way.

\todo[inline]{Ono je to spíš naopak. To, že známe dotazy, nám může omezit prostor možných XML schémat, která popisují strukturu XML dat. Jinak řečeno, může nám to zrychlit odvozování struktury, protože z dotazu víme, že některé možnosti můžeme vyřadit.}

Considering the described issues, we concluded not to deal with the inference of XML structure in this thesis.

\todo[inline]{Ta věta je nejasná. Spíš pro to odvození struktury použijeme některý standardní přístup analyzující data a dotazy použijeme pro další upřesnění, ne? Nebo strukturu nebudeme řešit vůbec? To je asi divné.}

\section{Extension of an Existing Approach}
The existing approaches of XML schema inference deal mainly with inference of XML structure. Hence, the extension of an existing approach will be a kind of an independent addition instead of modification and refinement of its core algorithm.

The existing approaches take the XML data on their input. Therefore, the basic idea is that the input will be extended also for XQuery queries and the algorithm will consist of three phases. The first phase will be taken from an existing approach and it will process the XML data to infer the XML structure. The second phase will process the XQuery queries and it will infer statements that can be inferred indepedently of the XML data. The third phase will merge the statements inferred in the second phase into the resulting schema. This phase may also infer additional statements from both the XML data and the queries or it may try to verify the statements from the second phase with respect to the XML data.

\todo[inline]{Také bychom mohli vzít přístup odvozující strukturu a informace z dotazů využít v  jeho průběhu. Obecně tyto metody vytvoří prefixový strom z iniciální gramatiky a pak se ho snaží zobecňovat sléváním stavů a zobecňováním automatu. Např. můžeme mít pravidlo, že pokud se element A vyskytuje alespoň 5x, pravděpodobně se může vyskytovat libovolněkrát. My ale v datech najdeme element jenom 4x. Pak nevím jeslti je pravidlo rozumné. Dotazy nám to mohou potvrdit/vyvrátit. Čili můžeme zpřesnit proces odvozování.
Nebo ho můžeme zoptimalizovat. Např. Vošta ve své diplomce poměrně složitě analyzuje automat aby našek konstrukt xs:all. My bychom to pomocí analýzy dotazů mohli umět jednodušeji = efektivněji.
Nebo jsme schopni pomocí dotazů přesněji určit kontext elementu (opět řeší Vošta v diplomce). Např. mám element jméno, který se vyskytuje v různých kontextech (absolutních cestách). Já ale nevím, jeslti ten element má stený význam a tudíž by pro něj měl být odvozen stejný model obsahu. Např. jméno autora může být složeno z podelementu křestní a příjmení, zatímco jméno knihy bude prostý string. Vošta používá podobnostní funkci, ale tam je potřeba nastavit threshold. Pokud ale budu mít dotaz, který mi tyto elementy dává do jedné proměnné (např. jméno zákazníka i jméno autora), zřejmě jsou sémanticky podobné a mohou mít stejný model obsahu. Stejný dotaz pro knihy i autory by byl asi divný. 
Tohle by asi nebylo špatné minimálně odiskutovat. Mrkněte se např. na diplomku Vošty (popř. Klempy). Jsou tam popsané typické postupy pro odvozování a základní pravidla slévání. U nich by také dotazy mohly pomoci.}