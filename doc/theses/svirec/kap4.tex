\chapter{Proposed Algorithm}

The main goal of this thesis is to propose an algorithm repairing XML document violating functional dependencies defined for this document. We use an XML tree and tree tuples to represent XML data. Next follows features we want to introduce in our algorithm:

\begin{itemize}
	\item Incorporation of weight model into the XML data representation to provide the selection of repair candidates with lowest modification cost.
    \item Involvement of user in the process of finding and applying repair candidates.
    \item Apply one repair candidate at the time and recalculate repair candidates again to prevent using unnecessary repairs to repair one violation and also to prevent of introducing new violations, which will not be repaired.
    \item The paths which creates a functional dependency are described with XPath language \cite{xpath}, where only paths with basic construction are allowed (only path constructed with "/", "//" or "@", no wildcards, "[]" or another constructs are allowed).
    \item We introduce a new concept of the so-called repair group, which clusters repair candidates (repair repairing one FD violation) repairing the same violation, or modifying the same part of the XML tree.
\end{itemize}


\section{Repairing Algorithm}

The proposed algorithm is based on the algorithm described in Section \ref{RepConstAnswers} presented in \cite{RepAndConsistentAnswer}. This algorithm was chosen because of simple representation of the XML data using a concept which corresponds with concept used in relational databases. Another reason is using besides modification of node value as an update operation also marking particular node information as unreliable, which can reveal forgotten inconsistencies in the data.

\begin{algorithm}
\caption{Repair RW-XML tree}
\label{propAlgo}
\begin{algorithmic}[1]
\REQUIRE{\ \\
$RXT = \langle RT, \omega \rangle$: RW-XML tree conforming a DTD $D$\\
$\mathcal{FD} = {F_1, \dots, F_m}$: Set of functional dependencies}
\ENSURE a unique repaired RW-XML tree

\STATE $resultRXT = RXT$
\WHILE{$resultRXT \not \models_w \mathcal{FD}$}
    \STATE $S = \emptyset$ \COMMENT Set of repair groups
    \FORALL{$(F: S \rightarrow p) \in \mathcal{FD}$ s.t. $RXT \not \models_w F$}
    	\FORALL{$t_1, t_2$ tuples of $RXT$ s.t. $t_1, t_2$ do not weakly satisfy $F$}
		    \STATE $S = S \cup computeRepairGroup(F, t_1, t_2, RXT, S)$
	    \ENDFOR
    \ENDFOR

    \STATE $R = getRepair(S, RXT)$
    \STATE $resultRXT = applyRepair(R, resultRXT)$
\ENDWHILE

\end{algorithmic}
\end{algorithm}

The algorithm is split into three steps, where second and third step are repeated until all violations are repaired. In the first step, XML document and FDs are loaded, and XML tree with corresponding tree tuples are created. Next step of the algorithm computes repair groups containing repair candidates for FD violations. In the third step chosen repair candidate is applied to an XML tree. In Algorithm \ref{propAlgo} we can see the simplified process of repairing XML FD violations, which covers second and third step of the whole algorithm.

\subsection{Initial data model}

To represent an XML document we use an extended R-XML tree (Definition \ref{rxmlTree}), called RW-XML tree, which has weights assigned to each node of the tree. The weight of an node is from interval $[0,1]$ and indicates correctness of the data the particular node holds, that means the higher the weight is, more correct particular node is. The weights are used to measure cost of repair candidates, where candidate with the lowest cost is picked to be applied to the XML tree. This is also a first place where interaction of the user can be applied. The user could assign weights to the nodes manually (described in \todo{sem doplnit odkaz do implementacnej sekcie}) or can use some sort of statistical methods to generate them automatically. If the user not assign weights nor use statistical methods, default weight is assigned to all nodes. A definition of an RW-XML tree follows:

\begin{define}[RW-XML tree]
A RW-XML tree is a pair $RWXT = \langle RXT, \omega \rangle$, where $RXT$ is an R-XML tree and $\omega$ is a weight function from $N_T$ to $[0,1]$.\qed
\end{define}

After creating RW-XML tree from input XML data, set of tree tuples (defined in Definition \ref{treeTuple}) are constructed. Since a set $paths(D)$, containing all possible paths defined in DTD $D$, can be infinite (DTD can define recursive structure of elements), the actual content of $paths(D)$ is modified to reflect the current structure of the RW-XML tree. Since definition of a tree tuple says that answer of the path $p$ contains at most one element, our modification of $paths(D)$ has no effect on constructing tree tuples if a DTD defines some optional path which is not defined for the RW-XML tree $RWXT$ (the set $p(RWXT)$ is empty).

Functional dependencies as defined in Definition \ref{fd1} consists of paths described with XPath. As was described before, these paths can only have basic construction shown in Example \ref{pathsExample}.

\begin{example}\label{pathsExample}
Example of paths that can be used in functional dependencies:
\begin{verbatim}
//bib/book/author
/bib/book/author/@ano
/bib/book/author/name/text()
\end{verbatim}
\end{example}

\subsection{Computing Repair Groups}

With created RW-XML tree $RWXT$ and corresponding tree tuples from an input data, we can now proceed to compute repair groups. Repair group is a set of repair candidates, which repairs the same FD or modifies the same part of $RWXT$. Each repair candidate is a pair of functions $\delta$ and $\varrho$ ($\langle \delta, \varrho \rangle$), where either modifies value of an RW-XML tree node ($\delta$ is defined) or marking a node as unreliable ($\varrho$ is defined). The $\delta$ function of repair candidate is defined same as in the XML tree (Definition \ref{xmlTree}) and defines new value of the RW-XML tree node. Similarly, $\varrho$ function defines the node which is marked as unreliable.

To be able to compute repair groups, we need to decide for which FDs violates $RWXT$. This can be achieved by finding all tree tuple pairs that not weakly satisfies particular FD (Definition \ref{weakSatisf}). For each tuple pair is then computed repair group (line 6 in Algorithm \ref{propAlgo}).

The function \texttt{computeRepairGroup}, responsible for creating the repair group, is shown in Algorithm \ref{repairGroupAlgo}. The function gets RW-XML tree, a functional dependency $F$, tuples $t_1$, $t_2$ and a set of repair groups $RGS$ and computes the repair group containing repair candidates as follows:

\begin{enumerate}
	\item First repair candidates are created using function $computeRepairs$ from Algorithm \ref{repAlgo} (line 1).Since R-XML tree is a special case of RW-XML tree where all weights are equal to zero, we can pass RW-XML tree as a parameter to this function.
    \item Next is checked if repair candidates intersect another candidates from existing repair groups (line 2)
    \begin{itemize}
    	\item If the candidates intersect with some group, they are added to this group (line 3)
        \item Otherwise new repair group containing repair candidates is created (line 5)
    \end{itemize}
\end{enumerate}

\begin{algorithm}
\floatname{algorithm}{Function}
\caption{$computeRepairGroup(F, t_1, t_2, RXT, RGS)$}
\label{repairGroupAlgo}
\begin{algorithmic}[1]
\REQUIRE{\ \\
$RXT = \langle T, \omega \rangle$: RW-XML tree conforming a DTD $D$\\
$F: X \rightarrow p$ functional dependency\\
$t_1, t_2$ tuples of $RXT$\\
$RGS$ set of repair groups}
\ENSURE $RG$: repair group

\STATE $S = computeRepairs(F, t_1, t_2, RXT)$ \COMMENT set of repair candidates

\IF{$candidatesIntersectRepairGroups(S, RGS)$}
\STATE $RG = getIntersectingRepairGroup(S, RGS)$
\ELSE
\STATE $RG = createNewRepairGroup(S)$
\ENDIF

\RETURN $RG$
\end{algorithmic}
\end{algorithm}

In Example \ref{repairExample} are shown repair candidates of one repair group modifying node values and marking nodes as unreliable.

\begin{example}\label{repairExample}
Consider XML data and functional dependency from Example \ref{fdrepairExample}, where XML data is graphically represented as XML tree $XT$ in Fig \ref{example1}. The $XT$ violates FD $$\{/bib/book, /bib/book/written\_by/author/@ano\} \rightarrow /bib/book/written\_by/author$$ because two authors of the same book have the same value of attribute $@ano$. One repair group with these repair candidates is created: $R_1 = \langle \{\delta(v5) = \perp\},\varrho_{\{\}}(v) \rangle$, $R_2 = \langle \{\delta(v9) = \perp\},\varrho_{\{\}}(v) \rangle$, $R_3 = \langle \{\},\varrho_{\{v4,v5,v6,v7\}}(v) \rangle$, $R_4 = \langle \{\},\varrho_{\{v8,v9,v10,v11\}}(v) \rangle$, $R_5 = \langle \{\},\varrho_{\{v2,v3,\dots,v13\}}(v) \rangle$.

First two repair candidates modifies the value of an attribute $@ano$ by assigning new generated value ($\perp$). Next two repair candidates mark each author node with its children nodes that has the same $@ano$ attribute respectively. The last candidate marks as unreliable whole subtree with the book node holding authors with the same attribute as root node.\qed
\end{example}

\subsubsection{Weight model of a Repair Group}

In this section, we introduce a weight model of a repair group, which will be used in the next step of our repair algorithm. Before we define a weight of repair group, let us denote some important notations.

Given a repair candidate $R$, we denote with $Modified_\delta(R)$ the set of nodes modified by $\delta$ function from $R$. Analogously, we denote $Modified_\varrho(R)$ the set of nodes modified by $\varrho$ function. The count of nodes modified by repair candidate $R$ is denoted with $\lambda(R)$. At last, we denote $PS(R)$ a set of paths defining all nodes modified by $R$ (example of the set $PS(R)$ is shown in Example \ref{PSExample}).

\begin{example}\label{PSExample}
Consider XML tree from Fig. \ref{example1} and a repair candidate, which marks nodes $v12$ and $v13$ as unreliable. Then the set $PS(R)$ contains following paths:
\begin{verbatim}
/bib/book/title
/bib/book/title/text()
\end{verbatim}\qed
\end{example}


Since each repair candidate consists of a set of nodes which are modified (marked as unreliable or has modified value), we can compute cost of each candidate. It is important to say, that in out approach, we prefer repair candidates that modify value of the nodes before those marking nodes as unreliable. Therefore we added the coefficient $k$ to the calculation of the repair candidate cost, so that the repair candidate modifying node value will have lower cost. The definition of repair candidate cost follows:

\begin{define}[Repair Candidate Cost]
Given an RW-XML tree $RXT$ and a repair candidate $R$, we define the cost of $R$ as:
$$cost(R) = \sum_{u \in Modified_\delta(R)} \omega(u) + \sum_{v \in Modified_\varrho(R)} \omega(v) \times k,$$
where $k$ is coefficient determining a priority of the repair candidate modifying value of node before that  marking node as unreliable.\qed
\end{define}

By default is $k$ set to value that cost of repair candidate marking unreliable node will be higher than the one that modifies node value. However this is another place, where can user intervene and change the priority of repair candidates. We show in Example \ref{koefK}, how $k$ can change costs of repair candidates.

\begin{example}\label{koefK}
Consider XML tree $XT$ and repair candidates from Example \ref{repairExample}. A default weight of all nodes $v$ of $XT$ is $\omega(v) = 0.5$. If the coefficient $k = 1$, cost of repair candidates would be as follows: $cost(R_1) = 0.5$, $cost(R_2) = 0.5$, $cost(R_3) = 2$, $cost(R_4) = 2$ and $cost(R_5) = 6$.
Let us assume, that a repair candidate with the lowest repair cost will be applied to $XT$. If we order costs of repair candidates from the lowest to the highest, you can see that candidates which have marked unreliable nodes are at the end (and will not be applied to $XT$).

However, if we set the coefficient $k = 0.1$, costs of candidates would be sorted as follows: $cost(R_3) = 0.2$, $cost(R_4) = 0.2$, $cost(R_1) = 0.5$, $cost(R_2)  = 0.5$ and $cost(R_5) = 0.6$. You can see that order of costs has significantly changed and the candidate which will be applied is $R_3$ (is marking nodes as unreliable).\qed
\end{example}

And finally, since a repair group is a set of repair candidates, its weight can be defined as follows:

\begin{define}[Repair Group weight]
Given an RW-XML tree $RXT$ and a repair group $RG$, we define the weight of $RG$ as the sum of costs of all repair candidates in the $RG$.
\end{define}

\subsection{Repair Candidate Selection and Application}

The last step of our algorithm can be divided into two parts, namely selection of the repair candidate and subsequent application of the candidate to RW-XML tree.

\subsubsection{Selection of the Repair Candidate}

The previous step of the algorithm computes repair groups containing repair candidates, which can repair violations of provided FDs. From this candidates, we must choose one that is applied on RW-XML tree. Since we introduced a weight model to the repair group, we can use the weight of repair groups and the cost of repair candidates to choose suitable candidate. In our approach, we introduce two distinct algorithms: first that not involve the user to process of selection and the second one that use the user interaction.

The first algorithm simply selects the first repair group with the lowest weight, and from it the repair candidate with lowest cost is selected.

The latter algorithm allows user to choose the repair candidate which is most suitable for his needs. Very important aspect of all user interactions in this kind of algorithm is that the user will not be willing to select more than ten repairs. We could simply allow user to switch to the first selection algorithm, but that not take in account previous user selections of repair candidates. Therefore we introduce in this algorithm a functionality, that is able from selection done by the user before, guess his next selection.

The function $selectRepairByUser(RGS, SR, t)$, responsible for selection of repair candidate involving user interactivity is shown in Algorithm \ref{selectUser}.

First is decided, if the algorithm is in a state that the user is selecting repair candidates (user selection mode), or the user leaves decision making on the algorithm using his previous selections (guess mode) (line 2). If we are still in user selection mode, the user choose from repair groups sorted by the weight the most convenient repair group, and from this group the user choose the repair candidate that will be applied on RW-XML tree (line 4). Repair candidates in each repair group are also sorted by the cost, working as a hint for the user which repair would be chosen by previous automatic method of selection. Last step of user selection mode is saving the information from selected repair candidate (line 5). This information consists of the FD which this candidate repairs, nodes the repair changes (their paths) and also if the change was a value modification or marking node as unreliable.

If the user has decided not to selecting repair candidates by himself, the algorithm goes into guess mode (staring on line 6). In this mode the algorithm checks all repair groups if some of it contains the repair candidate, that is sufficiently similar with some previously selected repair candidate (line 7-10). This similarity is checked by function \texttt{canBeUsedUserSelection} shown in Algorithm \ref{canUserSel}. If neither of candidates is sufficiently similar, the algorithm choose repair candidate with the lowest cost from the repair group with the lowest weight (line 15-16).

\begin{algorithm}[H]
\floatname{algorithm}{Function}
\caption{$selectRepairByUser(RGS, SR, t)$}
\label{selectUser}
\begin{algorithmic}[1]
\REQUIRE{\ \\
$RGS$ set of repair groups\\
$SR$: set of previously selected repair candidates by the user\\
$t$: modified nodes count threshold of previously selected repair candidates\\}
\ENSURE $R$: repair candidate

\STATE $R = \emptyset$
\IF{$isUserSelection()$}
    \STATE \COMMENT repair candidate selected by user
    \STATE $R = getRepairFromUser()$
    \STATE $saveSelectedRepair(SR, R)$
\ELSE
    \FORALL{$RG$ in $RGS$}
        \STATE \COMMENT for all repair candidates in the repair group
        \FORALL{$RC$ in $RG$}
            \IF{$canBeUsedUserSelection(SR, t, RC)$}
                \RETURN $RC$
            \ENDIF
        \ENDFOR
    \ENDFOR
    \STATE $RG = getFirstRG(RGS)$ \COMMENT get the repair group with smallest weight
    \STATE $R = getFirstRepairCandidate(RG)$ \COMMENT get the repair candidate with the lowest cost
\ENDIF

\RETURN $R$
\end{algorithmic}
\end{algorithm}

The function \texttt{canBeUsedUserSelection} gets actual repair candidate $RC$, set of all previously selected repair candidates $SR$, modified nodes count threshold $t$ from interval $(0,1]$ of previously selected repair candidate and determine if $RC$ is sufficiently similar as some repair candidate from $SR$. To be similar with some previously selected repair candidate $S$, $RC$ must repair the same $FD$ as $S$, it must use the same update operation as $S$ and $\lambda(RC) \geq \lceil\lambda(S) \times t\rceil$ (line 2). Furthermore, if $\lambda(RC) = \lceil\lambda(S) \times t\rceil$, set of paths $PS(RC)$ must be a subset of $PS(S)$ (line 3). Otherwise, if $\lambda(RC) > \lceil\lambda(S) \times t\rceil$, there must exists a subset of $PS(S)$ with $\lceil\lambda(S) \times t\rceil$ elements that is subset of $PS(RC)$. In other words, without taking into account the threshold $t$, if a repair candidate $R_1$ modifies some nodes, the sufficiently similar repair candidate $R_2$ is such that modifies at least the same nodes as $R_1$ (when we say the same nodes we mean same paths representing those nodes). The threshold $t$ can reduce count of modified nodes of some previously selected repair candidate $R_1$, which means that sufficiently similar repair candidate needs to modify fewer nodes that are similar with nodes modified by $R_1$. In Example \ref{tresholdExample} is shown the usage of the threshold $t$.


\begin{algorithm}
\floatname{algorithm}{Function}
\caption{$canBeUsedUserSelection(SR, t, RC)$}
\label{canUserSel}
\begin{algorithmic}[1]
\REQUIRE{\ \\
$SR$: set of previously selected repair candidates by the user\\
$t$: suitability threshold $(0,1]$ of previously selected repair candidates\\
$RC$: actual repair candidate}
\ENSURE \TRUE\ if actual repair candidate is similar to some previous one.
\FORALL{$S$ in $SR$}
    \IF{$S$ repairs the same FD as $RC$ \AND $S$ use the same update operation as $RC$ \AND $\lceil\lambda(SC) \times t\rceil \leq \lambda(RC)$}
        \IF{$\lceil\lambda(SC) \times t\rceil = \lambda(RC)$ \AND $PS(RC) \subseteq PS(SC)$}
            \RETURN \TRUE
        \ENDIF
        \IF{$\lceil\lambda(SC) \times t\rceil < \lambda(RC)$ \AND there exists a subset $s$ of $PS(SC)$ with $\lceil\lambda(SC) \times t\rceil$ elements, that $s \subseteq$ $PS(RC)$}
            \RETURN \TRUE
        \ENDIF
   \ENDIF
\ENDFOR
\RETURN \FALSE
\end{algorithmic}
\end{algorithm}

\begin{example}\label{tresholdExample}
Consider repair candidate $R_1$ selected by user, that marks as unreliable two nodes and $PS(R_1) = \{/bib/book/title, /bib/book/title/text()\}$. Next consider repair candidate $R_2$ with $PS(R_2) = \{/bib/book/title/text()\}$, that the modified node is marked as unreliable and both $R_1$ and $R_2$ repairs the same $FD$. If threshold $t=1$, $R_2$ is not considered as sufficiently similar to $R_1$, because $\lceil\lambda(R_1) \times t\rceil > \lambda(R_2)$. However, if threshold is $t=0.5$, $\lceil\lambda(R_1) \times t\rceil = \lambda(R_2)$ and $PS(R_2) \subseteq PS(R_1)$, then $R_2$ is sufficiently similar to $R_1$.\qed
\end{example}

\subsubsection{Application of the Repair Candidate}

In this part, the selected repair candidate is finally applied to the RW-XML tree. If after this part the RW-XML tree not violates any of FDs, the whole repair algorithm ends at this point, otherwise repair groups are regenerated and the selection of the repair candidate part take place.

To apply the selected repair candidate $R$ to the RW-XML tree $RXT$ means, that we compose $\delta$ and $\varrho$ functions of $R$ with the corresponding functions of R-XML tree contained in $RXT$. This compositions are defined in Definition \ref{compDelta} and \ref{compVarrho}.

After application of the repair candidate, some of RW-XML tree nodes could become unreliable, which can lead to the situation that some of tree tuples are not anymore considered as a tuple (is no longer a maximal subtree). Therefore, we need before regeneration of repair groups also check all tree tuples, if they satisfies definition of tree tuple.
