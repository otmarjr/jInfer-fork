\chapter{Proposed Algorithm}
\todo[inline]{Nejaky uvod a zkratke hrnutie}
\todo[inline]{Lexikalna a syntakticka analyza z diplomky J. Schejbala}
\todo[inline]{Staticka analyza typov vyrazov}
\todo[inline]{Predpoklad korektnosti dotazov}

\section{Step 1: Construction of a Syntax Tree}
The first step of the algorithm involves lexical and syntactic analyses known from compilers and produces a so-called syntax tree. The analyses are taken from Ji\v r\'{i} Schejbal's master thesis \todo{ref}. Since they are not directly related to the inference, and thus, they are not directly related to the topic of this thesis, we will not describe them. Nevertheless, they provides us with a helpful processing of XQuery queries and we can focus on the inference.

The syntactic analysis needs to be slightly modified to suit our case. It writes its result into a file in an XML representation. Instead, we need to keep the result in memory and pass it to consecutive steps of our algorithm. Though this requirement concerns modifications of implementation, the core of the processing remains untouched. Therefore, we also do not describe these modifications.

\todo[inline]{Toto vše je OK, ale asi budeme potřebovat vědět, co nám z té analýzy leze za informace se kterými dál pracujeme. Čili vstupy našeho algoritmu je potřeba popsat přesně, ideálně formálně, tj. je to asi nějaký strom T= (V, E), kde V je... atd. Jeslti už je to pak implementováno jako objekty v paměti nebo XML data je celkem jedno a bude popsáno v kapitola Implementation.}

\subsection{Definition of the Syntax Tree}
\begin{definition}
Syntax tree of a XQuery query $Q$ is a tuple $T = (V, E, o)$ where $V$ is a set of nodes representing XQuery language constructs (TODO\todo{kompletny zoznam}), $E$ is a set of edges - couples $(a,b):a,b \in V$ and $o:V \rightarrow \mathbb{N}$ is an ordering function and $T$ satisfies the following conditions:
\begin{itemize}
\item $(V,E)$ is a tree.
\item The root node is $ModuleNode$ representing the entire query Q.
\item $(a,b)$ is an element of $E$ if and only if $b$ is a direct component of construct $a$ in $Q$.
\item For every node $a \in V$ the ordering function $o$ is defined as follows \\* $o(a) = \left\{
	\begin{array}{ll}
		1  & \mbox{if }a\mbox{ is the root node} \\
		seq(a) & \mbox{else}
	\end{array}
\right.$ \\* where $seq(a)$ is a sequential number of appearence of construct $a$ in $Q$.
\end{itemize}
\end{definition}

\subsection{Syntax Tree Nodes}
\todo[inline]{Dat do appendixu?}
Nodes of the syntax are organized in an is-a hierarchical structure, commonly used in the object oriented programming languages, where a simple node can be of several types. Nodes with emphasised names express a common type of a group of nodes, their descendants, and these type nodes cannot be directly used in the syntax tree. The remaining nodes represent particular constructs of the XQuery language and their instances can be used as nodes of the syntax tree. Each of the instances additionaly contains details about the particular form of the respective XQuery construct used in the query.

\todo[inline]{V ExprNode si pamatame aj typ vyrazu}

For example, an instance of the syntax tree cannot directly contain nodes $Node$ and $ExprNode$, but it can contain instances of nodes $AttributeNode$ and $LiteralNode$. Regarding the types, an instance of $LiteralNode$ node is of three types: $LiteralNode$, $ExprNode$ and $Node$. It carries information on a type of the literal and its value, for example $xs:integer$ of value $5$. 

\begin{description}
\item \textbf{Node}
\begin{description}
\item AttributeNode
\item AttrListNode
\item AxisNode
\item CaseClauseNode
\item CaseClausesNode
\item CDataSectionNode
\item ContentNode
\item DefaultCaseNode
\item EntityRefNode
\item \textbf{ExprHolderNode}
  \begin{description}
  \item BindingSequenceNode
  \item DefaultValueNode
  \item ElseExpressionNode
  \item OperandExpressionNode
  \item ReturnClauseNode
  \item TestExpressionNode
  \item ThenExpressionNode
  \item WhereClauseNode
  \end{description}
\item \textbf{ExprNode}
  \begin{description}
  \item CommaOperatorNode
  \item ConstructorNode
  \item ContextItemExprNode
  \item EmptySequenceNode
  \item ExtensionExprNode
  \item FLWORExprNode
  \item FunctionCallNode
  \item IfExprNode
  \item LiteralNode
  \item OperatorNode
  \item OrderedExprNode
  \item PathExprNode
  \item QuantifiedExprNode
  \item TypeswitchExprNode
  \item UnorderedExprNode
  \item ValidateExprNode
  \item VarRefNode
  \end{description}
\item FunctionBodyNode
\item CharRefNode
\item InClausesNode
\item \textbf{ItemTypeNode}
  \begin{description}
  \item AnyItemNode
  \item AtomicTypeNode
  \item KindTestNode
  \item NameTestNode
  \end{description}
\item LocationHintNode
\item LocationHintsNode
\item \textbf{ModuleChildNode}
  \begin{description}
  \item ModuleDeclNode
  \item PrologNode
  \item QueryBodyNode
  \end{description}
\item ModuleNode
\item NameNode
\item OrderByClauseNode
\item OrderSpecNode
\item ParamListNode
\item ParamNode
\item PITargetNode
\item PragmaListNode
\item PragmaNode
\item PredicateListNode
\item \textbf{PrologChildNode}
  \begin{description}
  \item BaseURIDeclNode
  \item BoundarySpaceDeclNode
  \item ConstructionDeclNode
  \item CopyNamespacesDeclNode
  \item DefaultCollationDeclNode
  \item DefaultNamespaceDeclNode
  \item EmptyOrderDeclNode
  \item FunctionDeclNode
  \item \textbf{ImportNode}
    \begin{description}
    \item ModuleImportNode
    \item SchemaImportNode
    \end{description}
  \item NamespaceDeclNode
  \item OptionDeclNode
  \item OrderingModeDeclNode
  \item VarDeclNode
  \end{description}
\item \textbf{StepExprNode}
  \begin{description}
  \item SelfOrDescendantStepNode
  \end{description}
\item StringNode
\item TupleStreamNode
\item TypeNode
\item \textbf{VariableBindingNode}
  \begin{description}
  \item ForClauseNode
  \item InClauseNode
  \item LetClauseNode
  \end{description}
\item VarValueNode
\end{description}
\end{description}

Some pseudo code algorithms in the following sections need to determine the type of a node instance. For this purpose, we define function $isA(nodeInstance, nodeType)$. The first argument is an instance of any node and the second is a node type itself. The function returns boolean value $true$ if the instance is of the specified node type, according to the described principle. Otherwise, it returns $false$.

For instance, assuming variable $literal$ is an instance of node $LiteralNode$, calls $isA(literal, LiteralNode)$, $isA(literal, ExprNode)$ return $true$, while call $isA(literal, ContentNode)$ returns $false$.

\subsection{Description of the Syntax Tree}
Since we modified only the implementation of the output form, the design of the syntax tree remains consequent to the entire design of the analyses. Each node represents a logical component of a query. Inner nodes stand for XQuery constructs that are composed of other constructs and can be further divided. Examples of such constructs are $FLWOR$, $if-than-else$ and function call. Leaf nodes represent elements of XQuery language that cannot be further divided. Typical representants are literal constants. \todo{zistit, ci konstanty nahodou nie su jedine}

\todo[inline]{\^ Toto bude potřeba popsat přesně, ne jen příkladem. Klidně převezměnte z diplomky JS.}

In detail, the syntax tree is a n-ary tree representing syntactic structure of a given query. Every node represents a certain XQuery construct and that is a type of the node. Some types can be divided into more specific subtypes. This is shown \todo{obrazok typov uzlov}.

\todo[inline]{\^ Toto je skoro stejný odstavec ne?}

An important characteric of the syntax tree is related to a definition of local variables and their scope. The representation of a definition of a local variable is $VariableBinding$ node. Nodes of this type contain only two subnodes; a type of the variable and a binding expression. The node and its subtree representing the type do not contain any expressions. The binding expression node is an expression node but the represented expression cannot use the variable which is just being bound. Therefore the scope of the new variable is not the subtree of the $VariableBinding$ node. Assuming \todo{Toto je velmi high-level popis na to, jak málo o syntaktickém stromě a dalších položkách víme.} the post-order numbering of the nodes, the new variable may be valid in some nodes with a higher post-order sequence number. Which \todo{Toto není anglický slovosled.} nodes that are, it depends on the type of the ancestor node(s).

For example, $FLWORExpr$ node contains four subnodes; $TupleStream$, $WhereClause$, $OrderByClause$ and $ReturnClause$. $TupleStream$ node contains a list of $VariableBinding$ node which define variables valid in all other three subnodes of the $FLWORExpr$ node.

\todo[inline]{priklad stromu}

\section{Step 2: Static Analysis of Expression Types}
In the second step, we statically (i.e. without evaluation of the queries) determine types of expressions in the syntax tree. Information on the types of expressions can be used by consecutive steps of the algorithm. The consecutive steps will not use the determined types of all expressions, however this step may be useful in a future extending.

\todo[inline]{Tady z těch try a probably je jasně vidět, že netušíte co vlastně přesně algoritmus bude dělat. Nejdříve si to rozmyslete, pak pište text. Rozhodně by se takové výrazy neměly v DP dobjevovat, působít o velmi nedůvěryhodně. Měl by to být strohý popis toho, co bylo uděláno.}

We want to capture the following types.

\begin{itemize}
\item XML Schema built-in atomic types \todo{link do appendixu}.
\item Type $xs:untyped$. \todo{to je co?}
\item Type representing any item. \todo{je potrebne?}
\item Type representing an element, attribute, item, node, text node, comment, processing instruction, document node.
\item Type representing a set of elements or attributes selected by a certain path expression. The path expression is included in this type. Let this type be identified as $pathType$.
\end{itemize}

\todo[inline]{Q: Akeho typu je napr path expression /root/(elementA * 2)? A: Datový typ je daný operátorem. Hodnota elementu se přetypuje.}

To capture sequences, we assign each type with its cardinality as proposed in \todo{ref na Schajbalovu diplomku}. Every type can be perceived as a sequence. A type representing one value or one item can be perceived as a sequence of exactly one item. The cardinality expresses one of the following five sequence types.

\begin{itemize}
\item An empty sequence.
\item A sequence of exactly one item.
\item A sequence containing zero or one item (modifier $?$).
\item A sequence containing zero or more items (modifier $*$).
\item A sequence containing one or more items (modifier $+$).
\end{itemize}

If we cannot determine the type of an expression, we express that using $null$. An example of such case is path expression $/rootElement/(elementA * 2)$. \todo{Nejak dopisat}

The analysis of expression types can be divided into three substeps. Determination of return types of functions, determination of types of global variables, and finally determination of types of expressions.

\todo[inline]{Este by sa dala urobit analyza volania funkcii, do ktorych su predavane nejake elementy/atributy o ktorych vieme ich path expression. Vysledkom tejto funkcie by totiz zas mohli byt elementy/atributy o ktorych vieme (pozmenenu) path expression a nie len nezname elementy/atributy.
A: Přesně tak. A jak říkám - není třeba vše co navrhnete implementovat.}

\subsection{Determination of Function Return Types}
Determination of return types of functions is needed because function calls can appear in expressions. A return type of a function can be determined at the moment the analysis of expressions encounters a call of the function, however, it involves multiple transitions of the syntax tree in a search for a definition of a particular function.

Instead, the syntax tree can be searched just once, before the analysis of expressions, and return types of all functions found are stored.

A simple algorithm is presented in Algorithm \ref{ALG_determination_of_function_return_types} \todo{Q: uvadzat aj taketo jednoduche funkcie? A: Obecně by mělo být popsáno vše. Ale pokud se nějaká jednoduchá věc např. opakuje, tak stačí napsat, že je algoritmus podobný jako v předchozím případě nebo tak něco.}. It uses \texttt{getFunctionDeclarationNodes()} function, which returns a list of all function declaration nodes in the syntax three. Actually, it does not have to search the whole syntax tree as the function declaration nodes can be present only in the query prolog section. 

For simplicity, we will focus on locally defined functions. We will not determine types of functions defined in other modules since the principle is similar but it is somewhat more difficult to implement \todo{Q: je to ok? A: No spíš napište něco jako without loss of generality.}. Return types of built-in functions are fixed and, thus, there is no need to analyze them.

\begin{algorithm}
\caption{Determination of Function Return Types}
\label{ALG_determination_of_function_return_types}
\begin{algorithmic}[1]
\ENSURE An associative array of function names with their types.

\STATE $functionTypes$ = empty associative array
\FORALL{$functionDeclarationNode \in getFunctionDeclarationNodes()$}
    \STATE $functionName = functionDeclarationNode.getFunctionName()$
    \STATE $functionTypes[functionName] = functionDeclarationNode.getReturnType()$
\ENDFOR
\RETURN $functionTypes$
\end{algorithmic}
\end{algorithm}

For the rest of the thesis, we assume function \todo{Většinou se na začátek sekce s algoritmem dává seznam používaných  funkcí a jejich význam.} \texttt{getFunctionReturnType()} which takes a function name and returns the return type of the function if the function is either built-in or it is recorded in the associative array. Otherwise, \texttt{null} is returned.

Later phases of the algorithm may need to process the function declarations. Therefore, we also store references to the entire function declaration nodes.

\subsection{Determination of Global Variable Types}
A similar approach as in the case of functions can be applied to determine types of global variables. Alike the functions, the global variables are defined in the prolog section. A type of a variable can be explicitly specified in its definition \todo{je to tak? priklad}. If it is not, it may often be deducible from the binding expression. Again, we do not analyse external variables for the same reason as in case of external functions.

\begin{algorithm}
\caption{Function determineExpressionType}
\label{ALG_func_determineExpressionType}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $exprNode$: An expression node in the syntax tree. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}
\ENSURE The expression type.

\STATE $type = null$
\IF{$isA(exprNode, LiteralNode)$}
     \STATE $type =$ ((LiteralNode)exprNode).type, exactly-once cardinality
\ELSIF{$isA(exprNode, FunctionCallNode)$}
     \STATE $type = getFunctionReturnType(((FunctionCallNode)exprNode).functionName)$
\ELSIF{$isA(exprNode, VarRefNode)$}
     \STATE $type = getVariableType(contextVarTypes, ((VarRefNode)exprNode).variableName)$
\ELSIF{$isA(exprNode, PathExprNode)$}
     \STATE $path = ((PathExprNode)exprNode).path$
     \IF{$path$ selects an element set}
         \STATE $type =$ element type, zero-or-more cardianlity, $path$ included
     \ELSIF{$path$ selects an attribute set}
         \STATE $type =$ attribute type, zero-or-more cardianlity, $path$ included
     \ELSE
         \STATE $type = null$
     \ENDIF
\ELSIF{$isA(exprNode, OperatorNode)$}
     \STATE $type = determineOperatorType(exprNode, contextVarTypes)$
\ELSIF{$isA(exprNode, FLWORExprNode)$}
     \STATE $returnClauseNode = ((FLWORExprNode)exprNode).returnClauseNode$
     \STATE $type = returnClauseNode.type$
\ENDIF

\RETURN $type$
\end{algorithmic}
\end{algorithm}

\todo[inline]{Napisat, ze determineOperatorType() tiez nie je kompletna}
\todo[inline]{definovat isOperatorClassAddition()}
\todo[inline]{definovat isNumericType()}
\todo[inline]{definovat isOperatorClassComparison()}

\begin{algorithm}
\caption{Function determineOperatorType}
\label{ALG_func_determineOperatorType}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $operatorNode$: An operator expression node in the syntax tree. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}
\ENSURE The operator expression type.

\STATE $type = null$
\STATE $operator = operatorNode.operator$
\IF{$isOperatorClassComparison(operator)$}
    \STATE $type = xs:boolean$
\ELSIF{$isOperatorClassAddition(operator) AND$ one of the operands is of a numeric type}
    \STATE $leftOperand = ((OperatorNode)exprNode).leftOperand$
    \STATE $rightOperand = ((OperatorNode).exprNode).rightOperand$
    \IF{$isNumericType(leftOperand.type) AND isNumericType(rightOperand.type)$}
        \STATE $type = selectMoreGeneralType(leftOperand.type, rightOperand.type)$
    \ELSIF{$isNumericType(leftOperand.type)$}
        \STATE $type = leftOperand.type$
    \ELSIF{$isNumericType(rightOperand.type)$}
        \STATE $type = rightOperand.type$
    \ENDIF
\ENDIF

\RETURN $type$
\end{algorithmic}
\end{algorithm}

The algorithm iterates through the variable declaration nodes from the prolog and if the variable is explicitly assigned with its type, the type is noted. Otherwise, an attempt of the type deduction of the expression is made. The deduction of the type from the expression is presented in Algorithm \ref{ALG_func_determineExpressionType}. On input, it takes an expression node and types of local variables that are valid in the expression (also called context of variables or variable context). The presented algorithm is just shortened illustration since the complete version is too long to be presented in this text. Nevertheless, the principle is straightforward. Depending on the class of the expression, its type can be either determined directly or it depends on its subexpressions. \todo{link na mozne triedy vyrazov.}

Function $determineExpressionType()$ is called within function $analysisOfExpressionTypes$ presented in Algorithm \ref{ALG_func_analysisOfExpressionTypes}, which recursively determines types of all subexpressions. Two important questions about this function emerge. How (in which order) are the tree nodes recursively processed and how does the function handle definitions (bindings) of new variables which may also appear in the expressions?

The order of the recursion is post-order. The reason is that an expression node may need to know types of its subexpressions to determine its own type and we want to determine types of all expressions. Therefore, using the post-order, subexpressions of an expression are processed first, and then the expression itself without any need for further recursion, because the types of the subexpressions are already determined.

The handling of new variable definitions relies on the fact that the definitions make the new variables valid only in nodes with a higher sequence number when numbered in the post-order \todo{overit}. Therefore, the left-most subnode of a certain node can be processed without an extension of the variable context. And, if the left-most subnode extends the variable context for the following nodes in the post-order numbering, it can be easily handled because the types of the new variables can be directly determined since the binding expressions are already processed (thus, their types are known). Every node ''knows'' wheather or not it may define new variables for nodes with higher sequence numbers. This is expressed in the algorithm by the condition at line 10. This condition is double-checked at line 3 where its meaning is that every node even ''knows'' if its particular subnode may define new variables. An example is a $FLWOR$ construct. The processing of $FLWOR$ knows that the first part (the first subnode) of this node may bind new variables using $for$ and $let$ constructs. After the subnode is processed, the processing of the $FLWOR$ node looks if any new variables were bound and if so the context of local variables is extended. This is done at line 4. Function $mergeContextVarTypes$ presented in Algorithm \ref{ALG_function_mergeContextVarTypes} writes every record from its second argument (the new variables) into ist first argument (the variable context). If there are records for variables with the same names in the context, they are overwritten to correspond to the variable overlaping. It is important to note that we assume the variable context is not passed by refence but by value, and hence, the variable context of a certain node is not affected by the recursive processing of its subnodes.

\begin{algorithm}
\caption{Function analysisOfExpressionTypes}
\label{ALG_func_analysisOfExpressionTypes}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $startingNode$: A node determinig a subtree to perform the analysis on \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}

\FORALL{$subnode \in$ all subnodes of $startingNode$}
    \STATE $analysisOfExpressionTypes(subnode, contextVarTypes)$ \COMMENT{recursion}
    \IF{$subnode$ defines new variables valid for following subnodes}
        \STATE $contextVarTypes = mergeContextVarTypes(contextVarTypes, subnode.variableTypes)$
    \ENDIF
\ENDFOR
\IF{$startingNode$ is expression node}
    \STATE $startingNode.type = determineExpressionType(startingNode)$
\ENDIF
\IF{$startingNode$ defines new variables valid in following nodes}
    \STATE determine types of the variables
    \STATE memorize their types in $startingNode.variableTypes$
\ENDIF
\end{algorithmic}
\end{algorithm}

\todo[inline]{Algoritmus analysisOfEXpressionTypes, line 10 - Tady tyhle věty jsou v pseudoalgoritmech divné. Měy by se vyskytovat minimálně. JInak je to pak v podstatě jen odřádkovaná věta, ne formální popis algoritmu bez technických detailů.}

\todo[inline]{Pozor na to přetékání textu - na spoustě míst.}

\begin{algorithm}
\caption{Function mergeContextVarTypes}
\label{ALG_function_mergeContextVarTypes}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $contextVarTypes$: Types of local variables valid in current context. \\    
    $extendingVarTypes$: Variable types of the same structure as the first argument and extending it.
}
\ENSURE The context variable types extended with the variable types from the second argument.

\FORALL{$varName \in keys(extendingVarTypes)$}
    \STATE $contextVarTypes[varName] = extendingVarTypes[varName]$
\ENDFOR
\RETURN $contextVarTypes$
\end{algorithmic}
\end{algorithm}

Function $analysisOfExpressionTypes$ called upon a binding expression of a global variable determines the type of the binding expression, and hence, the type of the variable. In case of global variables, the argument $contextVarTypes$ is empty, because there are no local variables valid in the prolog section.

\begin{algorithm}
\caption{Function getVariableType}
\label{ALG_function_get_variable_type}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $contextVarTypes$: Types of local variables valid in current context. \\
    $var$: A variable to determine the type of.
}
\ENSURE The type of variable $var$.

\IF{$contextVarTypes[var]$ is defined}
     \RETURN $contextVarTypes[var]$
\ELSE
     \RETURN $getGlobalVariableType(var)$
\ENDIF
\end{algorithmic}
\end{algorithm}

The types of processed global variables are available trough function $getGlobalVariableType()$. If the function gets a variable that is not a global one, it returns $null$. Function $getVariableType()$ called in Algorithm \ref{ALG_func_determineExpressionType} is defined in Algorithm \ref{ALG_function_get_variable_type}. It checks if the specified variable is amongst the given local variables. If so, it returns its type, else it handles the variable as a global one and if such global variable does not exist the result is $null$.

\subsection{Determination of Expression Types}
To determine types of expressions, we use already introduced function $analysisOfExpressionTypes$. The starting node (its first argument) is the node representing the query body and the variable context is empty as there cannot be any local variable valid in the body node.

We can also determine expression types in functions. To do this for a certain function, $analysisOfExpressionTypes$ function has to be called with a function declaration node as the starting node. In this case, the function declaration node contains a subnode specifying function's formal arguments. These argument are set as the variable context for the function body represented by another subnode.

\section{Step 3: Inference of Built-in Types}
In this step, the algorithm goes through the syntax tree to infer types of elements and attributes from expressions using the type information from the previous step. These two steps could be merged together but for better comprehension we present it separately.

How are the types inferred from the expression types? We do not exploit all expressions. Only expressions of a particular type are exploited. Specifically, an expression has to contain an subexpression $E$ of $pathType$ type (expression representing a certain element or attribute or set of elements or attributes). In the following text, the set represented by expression $E$ is denoted $S$. Another requirement is that the expression has to be either a function call or an arithmetic operation \todo{Q: Nejake ine ako napr type constructor, cast as? Princip je stale rovnaky. A: ak to jen popište. To je naprosto OK.}.

The output of this step is a set of couples ($pathType$, XML Schema built-in type).

\todo[inline]{Zlucovanie odvodenych tvrdeni.}
\todo[inline]{Path expressions s predikatmi.}

\subsection{Function Calls}
This case is quite straightforward. The algorithm encounters a function call and one of the arguments is a known set of elements of attributes (subexpression $E$ representing $S$). To determine the type of $S$, it is only needed to determine the type of the corresponding formal argument from the definition of the function. The function is either a built-in one so its definition is known or it is defined in the prolog section. External functions are not processed as was mentioned already.

If the type $T$ of the formal argument is a built-in type or its sequence, then $T$ is also the inferred type of $S$. Otherwise, no statement is inferred.

\subsection{Arithmetic Operations}
If the operator is one of $+$, $-$, $*$, $div$, $mod$ (the class of the expression is $Operator$ and the class of the operator is one of $PLUS$, $MINUS$, $MUL$, $DIV$, $MOD$ \todo{Niekam napisat mozne triedy operatora}), one operand is $E$ and the type $T$ of the other operand is one of numeric built-in types, then $T$ is also the inferred type of $S$.

If the operator is one of $<$, $>$, $<=$, $>=$, $=$, $!=$ (the class of the expression is $Operator$ and the class of the operator is one of $GEN\_LESS\_THAN$, $GEN\_GREATER\_THAN$, $GEN\_LESS\_THAN\_EQUALS$, $GEN\_GREATER\_THAN\_EQUALS$, $GEN\_EQUALS$, $GEN\_NOT\_EQUALS$), one operand is $E$ and the type $T$ of the other operand is one of built-in types, then $T$ is also the inferred type of $S$.

\todo[inline]{Pěkné, neškodilo by proložit příklady, tj. dotaz, strom, co z něho odvodíme.}