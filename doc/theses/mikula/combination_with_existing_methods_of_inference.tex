\chapter{Combination with Existing Methods of Inference} \label{CHAPTER_combination_with_existings_methods_of_inference}
In this chapter, we describe how to incorporate the inferred statements to existing methods of XML schema inference. We focus on a class of methods which are based on a creation and subsequent simplification of the initial grammar (as discussed in Chapter \ref{chapter_analysis_of_recent_approaches}).

The initial grammar contains rules of form $e \rightarrow e_1e_2\dots e_k$, where $e$ is an element and $e_1, \dots , e_k$ are its subelements. After the simplification, the simplified grammar contain rules of form $e \rightarrow E$, where $E$ is a regular expression composed of subelements of element $e$, describing its content.

Attributes of elements are not contained in the grammar directly, but every element carries an information on its attributes.

The combination with such methods of inference is straightforward. The rules of the grammar describe the XML structure using the most general aspect of elements and their subelements. Since the statements inferred by our method do not involve the XML structure by defining a subelement structure of elements, there are no conflicts between the grammar rules and our statements that need to be resolved.

Our statements are of the three following forms. The first one is $p \rightarrow t$, where $p$ is a PathType representing an XQuery path selecting a set of elements or attributes, and $t$ is an XSD built-in atomic type.

The second and third forms are $k = (C,P,\{L\})$ and $fk = (C(P_1,\{L_1\}) \rightarrow (P_2,\{L_2\}))$, representing a key and a foreign key, where $C,P,P_1,P_2,L,L_1,L_2$ are PathTypes without predicates using only child and descendant axes.

In all three cases, we want to determine elements from the grammar (or their attributes), targeted by the respective paths ($p$ from the first form and $C$ from the second and third form). This is done in two steps. The first one is normalization of a particular PathType and the second one is selection of the targeted elements.

\section{Evaluation of Paths}
A path represented by PathType can contain variable references and association of these references with other paths. That is the reason why the normalization is convenient. It simply finds the variable references in the path and replaces them with steps from the associated paths, which are normalized recursively.

The selection of elements is a simplified XPath evaluation. The simplification involves two aspects; the evaluation is not performed upon XML data, but the simplified grammar containing rules with a regular expression on their right side, and, partially related, predicates in path steps are not evaluated, they are ignored.

It iterates through steps of a path, maintaining a so-called \emph{context set}, which is a set of elements to evaluate the current step upon. The evaluation of one step is shown in Algorithm \ref{FUNC_evaluate_step}. For the retaining of readability of the code, we present an evaluation of self or descendant, child, and attribute axes, and nodes specified by name.

\begin{algorithm}
\caption{Function evaluateStep}
\label{FUNC_evaluate_step}
\begin{algorithmic}[1]
\REQUIRE{\ \\
	$step$: An instance of StepExprNode representing a step of the path to evaluate.
	$contextSet$: A set of elements and attributes to evaluate $step$ upon.
	$grammar$: The grammar.
}

\ENSURE A context set after the step evaluation.

\IF{$is(step,$ SelfOrDescendantStep$)$}
	\RETURN $evaluateStep\_selfOrDescendant(contextSet, grammar)$
\ENDIF

\STATE $newContextSet :=$ an empty set

\STATE $axisKind := step.getChild(axisNode).axisKind$
\STATE $nodeName := step.getChild(axisNode).getChild(nameTestNode).name$
\IF{$axisKind =$ CHILD}
	\FORALL{$node \in contextSet$}
		\IF{$node$ is element}
			\STATE $subelements := getTokens(grammar[node])$
			\FORALL{$subelement \in subelements$}
				\IF{$subelement.name = nodeName$}
					\STATE add $subelement$ to $newContextSet$
				\ENDIF
			\ENDFOR
		\ENDIF
	\ENDFOR
\ELSIF{$axisKind =$ ATTRIBUTE}
	\FORALL{$node \in contextSet$}
		\IF{$node$ is element}
			\STATE $attributes := node.attributes$
			\FORALL{$attribute \in attributes$}
				\IF{$attribute.name = nodeName$}
					\STATE add $attribute$ to $newContextSet$
				\ENDIF
			\ENDFOR
		\ENDIF
	\ENDFOR
\ENDIF

\RETURN $newContextSet$
\end{algorithmic}
\end{algorithm}

At first, the algorithm determines the axis of the step. If it is self or descendant axis, it returns the result of \texttt{evaluateStep\_selfOrDescendant} function. This function returns the given context set extended by all descendants of the elements from the context set in the given grammar.

If the axis is child axis, for each element in the context set, the algorithm determines its subelement using the grammar, and, if those with the name equal to the name specified by to step are added to the resulting context set. Function \texttt{getTokens} at line 10 retrieves all elements from a regular expression. A specific form of the regular expression is not important, because we only need to know which elements are possible subelements of the particular element.

And, at last, if the axis is attribute axis, elements from the context set are searched to contain an attribute with the specified name and those found attributes are added to the result.

\section{Saving the Inferred Statements}
In case of keys, the algorithm iterates through the inferred key statements. A key's context path $C$ is evaluated and the key is assigned to the target elements selected by the context path, one element can be assigned with multiple keys. Additionally, each key is assigned with a list of foreign keys that are referencing it.

In case of inferred types, the situation is slightly less simple, because there can occur conflicting statements. The examples of such conflicts for path $p$ without predicates are $p_1 \rightarrow date$, $p_2 \rightarrow string$, and, $p_1 \rightarrow byte$, $p_2 \rightarrow int$, where $p_1$, $p_2$ are paths that when stripped of predicates, they equal $p$.

Note that, in both examples, one type is castable to the other (date to string, and byte to int). Both types are inferred correctly for nodes targeted by $p$, but one of them was inferred from a more convenient expression and is more precise.

Consider these two expressions; PathType $p$ is compared to an integer literal constant, and, PathType $p$ is an argument of function where a formal type of the argument is byte. The first expression is utilized to infer statement $p \rightarrow integer$, and the second one to infer statement $p \rightarrow byte$. Both of the types are correct, but the second one is more accurate.

A problem emerges for example if PathType $p$ is compared to an integer constant, and the real type of elements (or attributes) selected by $p$ is \texttt{double}. In that case, statement $p \rightarrow$ \texttt{integer} is inferred, but it is not correct.

\subsection{Verification using XML data}
To solve the problems, we propose a simple verification using XML data.

For each normalized PathType $p$ from the inferred type statements $\mathcal{S}_t$, we find set $T_p$ of all inferred types. $T_p = \{t|(p \rightarrow t) \in \mathcal{S}_t\}$. Then, we create sequence $T_p'$ by ordering the set $T_p$ from the most specific type to the most general one. For example, if $T_p = \{$\texttt{double}, \texttt{byte}, \texttt{int}$\}$, $T_p' = ($\texttt{byte}, \texttt{int}, \texttt{double}$)$.

Since we have the XML data and path $p$ is an XQuery path, we can use an XQuery processor (a program that evaluates XQuery paths or queries) to select nodes $N$ targeted by $p$. The verification algorithm iterates through $T_p'$ and for each $t' \in T_p'$ it checks if every node in $N$ conforms to $t'$. If so, $t'$ is the inferred type for nodes $N$ (and PathType $p$), else the inferred type is \texttt{string}.
