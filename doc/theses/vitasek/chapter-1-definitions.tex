\chapter{Definitions}

TODO we shall introduce a number of definitions, some only auxiliary, some necessary in the whole work

\section{XML Tree}

We shall use the representation introduced in \cite{fidax}, where an XML file is represented by a labeled tree consisting of nodes for elements, attributes and simple text data. This tree shall be called an \textit{XML tree}. For a given node $v$ of an XML tree we define $label(v)$ (name of the node in in the document, only for elements and attributes), $id(v)$ (unique identifier across the document) and $value(v)$ (text content, only for attributes and simple text data) in the same way as the referenced article does.

Without a loss of generality we ignore the actual ordering of nodes in the tree.

\paragraph{Example}

This example introduces an XML file fragment that will be used for demonstration throughout this work. XML tree representing it is in Figure \ref{image-definitions-example-xml-tree}, where each node is annotated with a triple $label(v) : id(v) : value(v)$.

\begin{verbatim}
<x>
  <y a="1" b="2"/>
  <y a="3" c="4"/>
  <y/>
  <z a="1"/>
</x>
\end{verbatim}

\begin{figure}
  \caption{Example XML Tree}
  \label{image-definitions-example-xml-tree}
  \centering
    \subfigure[XML tree]{\includegraphics[width=.45\textwidth]{images/definitions/xml-tree}}
    \subfigure[Attribute mappings]{\includegraphics[width=.45\textwidth]{images/definitions/xml-tree-ams}}
\end{figure}

Furthermore, we denote $I$ % TODO fix the capital I
the set of all ids and $V$ % TODO fix the capital V
the set of all values in the document. We will need two more definitions from the article.

\begin{define}[Node equality]
	$v_1$ and $v_2$ are node equal, written $v_1 =_n v_2$ iff $id(v_1) = id(v_2)$.
\end{define}

\begin{define}[Value equality]
	$v_1$ and $v_2$ are value equal, written $v_1 =_v v_2$ iff $value(v_1) = value(v_2)$.
\end{define}

\section{ID, IDREF, IDREFS Attributes}
\label{section-definitions-id-attributes}

According to \cite{Bray:08:EML}, an XML attribute may have the type \textit{ID}, \textit{IDREF} or \textit{IDREFS} (among others). Following constraints are related to these types.

\begin{quote}
\textbf{Validity constraint: ID}

Values of type \textbf{ID} \textsc{must} match the Name production. A name \textsc{must not} appear more than once in an XML document as a value of this type; i.e., \textbf{ID} values \textsc{must} uniquely identify the elements which bear them.

\textbf{Validity constraint: One ID per Element Type}

An element type \textsc{must not} have more than one \textbf{ID} attribute specified.

\textbf{Validity constraint: ID Attribute Default}

An \textbf{ID} attribute \textsc{must} have a declared default of \textbf{\#IMPLIED} or \textbf{\#REQUIRED}.

\textbf{Validity constraint: IDREF}

Values of type \textbf{IDREF} \textsc{must} match the Name production, and values of type \textbf{IDREFS} \textsc{must} match Names; each Name \textsc{must} match the value of an \textbf{ID} attribute on some element in the XML document; i.e. \textbf{IDREF} values \textsc{must} match the value of some ID attribute.
\end{quote}

\section{XML Keys}

TODO

\subsection{According to Specification}

TODO compare them to ID attributes

\subsection{According to \cite{keX}}

TODO show how a XML key is defined using the keX notation % this is a terrible sentence

\section{Attribute Mappings}

Now we return to \cite{fidax} to define the notion of an \textit{attribute mapping} (or AM for short). \nomenclature{AM}{Attribute Mapping}
We will use a different definition (without introducing keys from \cite{keX} for now) that will however give us the same result.

\begin{define}[$\Sigma^E$, $\Sigma^A$, $\Sigma$]
	$\Sigma^E$ is the set of all element labels, $\Sigma^A$ is the set of all attribute labels. $\Sigma = \Sigma^E \cup \Sigma^A$ is their union and effectively the set of all labels in the document (simple text data nodes do not have a label).
\end{define}

\begin{define}[Attribute mapping]
	For $x \in \Sigma^E$ and $y \in \Sigma^A$ we define the \textit{attribute mapping} of y over x, denoted $M_{x}^{y}$, the $I \times I$ % TODO fix the capital I
	relation defined by
	\[M_{x}^{y} = \{ (z,w): label(z) = x, label(w) = y, parent(w) = z \}\]
\end{define}

Thus the relation $M_{x}^{y}$ contains edges in the XML tree connecting element nodes labeled $x$ and attribute nodes labeled $y$.

We can use projection to retrieve all the unique \textit{ids} of either elements or attributes from the relation, with notation $\pi_E(M_{x}^{y})$ and $\pi_A(M_{x}^{y})$.

\begin{define}[Type of the attribute mapping]
	Attribute mapping $M_{x}^{y}$ is of the \textit{type} $\tau(M_{x}^{y}) = x$.
\end{define}

\paragraph{Example}
The XML tree from Figure \ref{image-definitions-example-xml-tree} has the following non-empty AMs drawn in bold lines: $M_{y}^{a} = \{(2,6), (3,8)\}$, $M_{y}^{b} = \{(2,7)\}$, $M_{y}^{c} = \{(3,9)\}$ and $M_{z}^{a} = \{(5,10)\}$.

Following example equations hold.
\begin{eqnarray*}
\pi_E(M_{y}^{a}) & = & \{2, 3\} \\
\pi_A(M_{z}^{a}) & = & \{10\} \\
\tau(M_{y}^{c}) & = & y
\end{eqnarray*}

\begin{define}[Image of the attribute mapping]
	\textit{Image} $\iota$ of the attribute mapping $M_{x}^{y}$ is defined as $\iota(M_{x}^{y}) = \{z: z = value(w), w \in \pi_A(M_{x}^{y})\}$
\end{define}

So the image of an AM is a set of all the values of all the attribute nodes contained in the mapping.

\paragraph{Example}
Again referring to the XML tree from \ref{image-definitions-example-xml-tree}, we get the following AM images.
\begin{eqnarray*}
\iota(M_{y}^{a}) & = & \{1, 3\} \\
\iota(M_{y}^{b}) & = & \{2\} \\
\iota(M_{y}^{c}) & = & \{4\} \\
\iota(M_{z}^{a}) & = & \{1\} \\
\end{eqnarray*}

\subsection{Attribute Mapping Model}

TODO

\section{ID Set}

Based on the requirements for an ID attribute from Section \ref{section-definitions-id-attributes} we will define ID set with the help of the following definition.

\begin{define}[Candidate attribute mapping]
An attribute mapping $m$ is a \textit{candidate attribute mapping} if it is an injective function, that is,
\[|m| = |\pi_E(m)| = |\pi_A(m)| = |\iota(m)|\]
\end{define}

\paragraph{Example}
In our example all the attribute mappings are candidate AMs.

Now we can proceed to define an ID set.

\begin{define}[ID set]
A set of candidate attribute mappings $I = \{m_1, \ldots m_n\}$ is an ID set iff
\[\bigcap_{m_i \in I} \tau(m_i) = \emptyset \wedge \bigcap_{m_i \in I} \iota(m_i) = \emptyset\]
\end{define}

That is, an ID set has images without repeating values and all the types are unique (an element cannot have more than one ID attribute).

\paragraph{Example}
Returning to our example, the following are all the possible ID sets: $\{ M_{y}^{a} \}, \{ M_{y}^{b} \}, \{ M_{y}^{b}, M_{z}^{a} \}, \{ M_{y}^{c} \}, \{ M_{y}^{c}, M_{z}^{a} \}$. Note that once we select an AM of type $y$ we can never add any other with the same type. Note also that $\{ M_{y}^{c}, M_{z}^{a} \}$ is not an ID set, because $\iota(M_{y}^{c}) \cap \iota(M_{z}^{a}) \neq \emptyset$.

\subsection{IDREF and IDREFS Attributes}

TODO

\section{Attribute Mapping Weight}

TODO this is from FIDAX again

$M = \{m_1, \dots m_i\}$ is the set of all non-empty AMs in the document.

\subsection{Support}

\begin{define}[Support]
\textit{Support} of an attribute mapping $m$ is defined as follows.
\[\phi(m) = \frac{|m|}{\sum_{p \in M}|p|}\]
\end{define}

TODO example

\subsection{Coverage}

\begin{define}[Coverage]
\textit{Coverage} of an attribute mapping $m$ is defined as follows.
\[\chi(m) = \left( \sum_{p \in M, p \neq m} |\iota(m) \cap \iota(p)| \right) / \sum_{p \in M} |\iota(p)|\]
\end{define}

TODO example