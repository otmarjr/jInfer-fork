\documentclass[a4paper,10pt,oneside]{article}
\usepackage{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{subfigure}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tgpagella}
%\usepackage[scale=0.9]{tgcursor}
%\usepackage[scale=0.9]{tgheros}
\usepackage{xstring}

\newcommand{\myscale}{0.74}
\newcommand{\vect}[1]{\boldsymbol{#1}}
\newcommand{\code}[1]{\texttt{\StrSubstitute{#1}{.}{.\.}}}
\def\.{\discretionary{}{}{}}
\newcommand{\jmodule}[1]{\texttt{\textit{#1}}}

\setlength{\hoffset}{-1in} %left margin will be 0, as hoffset is by default 1inch
\setlength{\voffset}{-1in} %analogous voffset
\setlength{\oddsidemargin}{1.5cm}
\setlength{\evensidemargin}{1.5cm}
\setlength{\topmargin}{1.5cm}
\setlength{\textheight}{24cm}
\setlength{\textwidth}{18cm}

\def\mftitle{jInfer BasicXSDExporter Module Description}
\def\mfauthor{Michal Klempa, Mário Mikula, Robert Smetana, Michal Švirec, Matej Vitásek}
\def\mfadvisor{RNDr. Irena Mlýnková, Ph.D., Martin Nečaský, Ph.D.}
\def\mfplacedate{Praha, 2011}
\title{\bf\mftitle}
\author{\mfauthor \\ Advisors: \mfadvisor}
\date{\mfplacedate}

\ifx\pdfoutput\undefined\relax\else\pdfinfo{ /Title (\mftitle) /Author (\mfauthor) /Creator (PDFLaTeX) } \fi

\begin{document}
\maketitle
\noindent Target audience: developers willing to extend jInfer, specifically hack the XSD export.

\noindent \begin{tabular}{|l|l|} \hline
Responsible developer: & Mário Mikula \\ \hline
Required tokens:       & none \\ \hline
Provided tokens:       & cz.cuni.mff.ksi.jinfer.base.interfaces.inference.SchemaGenerator \\ \hline
Module dependencies:   & Base \\ \hline
Public packages:       & none \\ \hline
\end{tabular}

\section{Introduction}

This is an implementation of a \jmodule{SchemaGenerator} exporting the inferred schema to XSD, supporting basic features of the language.

\section{Structure}

The main class implementing \code{SchemaGenerator} inference interface and simultaneously registered as its service provider is \code{SchemaGeneratorImpl} in package \code{cz.cuni.mff.ksi.jinfer.basicxsd}. Process of export consists of two phases described in detail in later sections.
\begin{enumerate}
	\item Preprocessing.
	\item The export to a string representation itself.
\end{enumerate}
Method \code{start()} first creates an instance of \code{Preprocessor} class supplied by rules (elements) it got in the simplified grammar on input. Phase of preprocessing is done by creating that instance (calling its constructor) and its purpose is to discover information such as which elements should be globally defined and which element is the root element.\\

Afterwards, \code{start()} method uses instances of classes derived from \code{AbstractElementsProcessor} class to export elements of input grammar.

\subsection{Preprocessing}

Code to handle preprocessing resides in package \code{cz.cuni.mff.ksi.jinfer.basicxsd.preprocessing}.

\subsubsection{Purpose}

As mentioned above, preprocessing is implemented in \code{Preprocessor} class and its functions are following.
\begin{itemize}
	\item Decide which elements should be defined globally.
	\item Remove unused elements.
	\item Find the top level element.
	\item Find an instance of element by its name.
\end{itemize}

\subsubsection{TODO spravny vyraz sem}

Constructor of \code{Preprocessor} class gets a list of elements and a number, defining minimal number of occurrences of an element to be defined globally. It first topologically sorts input elements to decide which of the elements is the root element. Afterwards, it counts occurrences of the elements and removes unused ones (those which did not occur). Finally, for each element it decides whether to mark it as a global one or not. An element is considered global if its occurrence count is greater than or equal to the number of occurrences provided on input.\\

\subsubsection{Running preprocessor and obtaining its result}

As described above, preprocessing is performed by creating an instance of \code{Preprocessor} class.\\

Information discovered by the preprocessing can be obtained by calling \code{Preprocessor}'s \code{getResult()} method. This method returns an instance of \code{PreprocessingResult} class. Purpose of this class is to provide of what the preprocessor has discovered and to provide an easy way to search the input grammar for an element by its name. For details see JavaDoc of \code{PreprocessingResult}'s public methods.

\subsection{Export}

XSD export itself is performed using classes derived from \code{AbstractElementsProcessor} class and a helper class named \code{Indentator}.

\subsubsection{Indentation}

To generate a human readable XSD output, it is necessary to apply correct indentation of XSD elements and their content. This is handled by \code{Indentator} class. This classes also serves as a buffer for string representation of XSD that the exporter is creating.\\

Instance of this class is a member variable of the module, it holds text appended to it and keeps indentation level state. Text can be appended without indentation (method \code{append()}) or indented (method \code{indent()}). Level of indentation can be incremented or decremented by methods \code{increaseIndentation()} and \code{decreaseIndentation()}. At the end of export, when textual representation of each element has been appended to the \code{Indentator}, \code{Indentator}'s method \code{toString()} will return string representation of the resulting XSD.\\

\subsubsection{Definition of elements}

Before we describe the export of elements, let's take a look on how we define elements and their attributes using XSD language.\\

Element is defined by XSD element \code{element}, specifying its name and type. Let \code{xs} be XMLSchema namespace.

\begin{verbatim}
<xs:element name="Person" type="...
\end{verbatim}

Type of an element is one of following.

\begin{itemize}
	\item XSD \emph{built-in type}. One of types like \code{xs:string}, \code{xs:integer}, \code{xs:positiveInteger}, etc.
	\begin{verbatim}
	<xs:element name="Person" type="xs:string"/>
	\end{verbatim}
	
	\item \code{simpleType}. Actually, exporter does not support any XSD features which are defined in \code{simpleType}. This means, that these types will not occur in result XSDs.
	\begin{verbatim}
	<xs:element name="Person">
	  <xs:simpleType>
	    ...
	  </xs:simpleType>
	</xs:element>
	\end{verbatim}
	
	\item \code{complexType}. This type can contain XSD element \code{xs:sequence} or \code{xs:choice}. Each of these elements can contain definitions of elements, \code{xs:sequence}s and \code{xs:choice}s again.
	\begin{verbatim}
	<xs:element name="Person">
	  <xs:complexType>
	    <xs:sequence>
	      <xs:element name="Name" type="xs:string"/>
	      <xs:element name="Surname" type="xs:string"/>
	      <xs:choice>
	      ...
	      </xs:choice>
	    </xs:sequence>
	  </xs:complexType>
	</xs:element>
	\end{verbatim}
	An \emph{empty element} is defined as empty \code{complexType}.
	\begin{verbatim}
	<xs:element name="EmptyElement">
	  <xs:complexType>
	  </xs:complexType>
	</xs:element>
	\end{verbatim}
\end{itemize}

Named type of an element is defined by XSD element \code{simpleType} (lack of features mentioned above) or \code{complexType} with specified attribute \code{name}. Its content is exactly the same as described above. There is of course no need to define \emph{built-in types}.

\begin{verbatim}
<xs:complexType name="PersonType">
...
</xs:complexType>
\end{verbatim}

Element of this type can be then defined by specifying name of the type.

\begin{verbatim}
<xs:element name="Person" type="PersonType"/>
\end{verbatim}

XSD elements \code{xs:element}, \code{xs:sequence} and \code{xs:choice} can have attributes \code{minOccurs} and \code{maxOccurs}. These attributes defines interval of number of instances of a particular element. Legal values of these attributes are non-negative integers.

\begin{verbatim}
<xs:element name="Person" type="PersonType" minOccurs="1" maxOccurs="3"/>
\end{verbatim}

Default values for \code{minOccurs} and \code{maxOccurs} attributes are "1", if they are not specified. So the example above has the same meaning as the following one.

\begin{verbatim}
<xs:element name="Person" type="PersonType" maxOccurs="3"/>
\end{verbatim}

Exporter supports types of \emph{mixed elements}. \emph{Mixed element} is an element that contains other elements as well as some text.

\begin{verbatim}
<mixedElement>
  some text
  <anotherElement/>
  another text
</mixedElement>
\end{verbatim}

\emph{Mixed element} type is defined as \code{complexType} with attribute \code{mixed="true"}. Definition of the element from the last example may be as following.

\begin{verbatim}
<xs:element name="mixedElement">
  <xs:complexType mixed="true">
    <xs:sequence>
      <xs:element name="anotherElement" type="..."/>
    </xs:sequence>
  </xs:complexType>
</xs:element>
\end{verbatim}


\subsubsection{Definition of attributes}

Attributes are defined by XSD element \code{xs:attribute} with attributes \code{name}, \code{type} and optional \code{use}. Elements \code{xs:attributes} have to be placed at the end of a \code{complexType} definition.

\begin{verbatim}
<xs:element name="Person">
  <xs:complexType>
  ...
  </xs:complexType>
  <xs:attribute name="age" type="xs:positiveInteger"/>
  <xs:attribute name="id" type="xs:string" use="required"/>
</xs:element>
\end{verbatim}

Attribute \code{type} is one of a built-in types. If an attribute is obligatory, this is defined by specifying \code{use="required"}. 

\subsubsection{Export of elements}

TODO

--------------------------------------------------------------------------------------







First, global elements are exported. For each element, its type is defined as a global type. TODO rio example. This is done by passing global elements to \code{processGlobalElement} method.

After global elements, others are exported by calling of method \code{processElement}, supplied by the top level element as its argument. Reference to a global element type is done simply by declaring element's name and type.

\begin{verbatim}
<xs:element name="Person" type="PersonType"/>
\end{verbatim}



To sa deje rekurzivnym priechodom so startom v korenovom elemente. Elementy, ktorych typy su definovane globalne a elementy so vstavanymi typmi, su exportovane jednoducho, uvedenim ich mena a typu. Ostatne elementy su definovane na mieste. TODO rio priklady. Na toto je potrebne zavolat metodu \code{processElement} s korenovym elementov, ako argumentom.




Code exporting attributes is in \code{attributeToString()}. First thing this method does is to assess the domain of a particular atribute: this is a map indexed by attribute values containing number of occurences for each such attribute. Type definition of an attribute is generated in the \code{DomainUtils.getAttributeType()} method. Based on a user setting, this might decide to enumerate all possible values of this attribute using the \code{(a|b|c)} notation, otherwise it just returns \code{\#CDATA}.\\
Attribute requiredness is assessed based on \code{required} metadata presence. If an attribute is not deemed required, it might have a default value: if a certain value is prominent in the attribute domain (based on user setting again), it is declared default.

\subsection{Preferences}

All settings provided by \jmodule{BasicDTDExporter} are project-wide, the preferences panel is in \code{cz.cuni.mff.ksi.jinfer.basicdtd.properties} package. As mentioned before, it is possible to set the following. 
\begin{itemize}
	\item Maximum attribute domain size which is exported as a list of all values (\code{(a|b|c)} notation).
	\item Minimal ratio an attribute value in the domain needs to have in order to be declared default.
\end{itemize}

\section{Data flow}

Flow of data in this module is following.
\begin{enumerate}
	\item \code{SchemaGeneratorImpl} topologically sorts elements (rules) it got on input.
	\item For each element, relevant portion of DTD schema is generated.
	\item String representation of the schema is returned along with the information that file extension should be "dtd".
\end{enumerate}

\nocite{*}
\newpage
\bibliographystyle{alpha}
\bibliography{literature}

\end{document}
