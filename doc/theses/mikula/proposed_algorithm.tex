\chapter{Proposed Algorithm}
\todo[inline]{Nejaky uvod}
\todo[inline]{Lexikalna a syntakticka analyza z diplomky J. Schejbala}
\todo[inline]{Staticka analyza typov vyrazov}

\section{Construction of a Syntax Tree}
The first step of the algorithm involves lexical and syntactic analyses and produces a syntax tree. The analyses are taken from Ji\v r\'{i} Schejbal's master thesis \todo{ref}. Since they are much more an issue of implementation than an issue of principle and they are not directly related to the inference, we will not describe them in this thesis.

The mentioned thesis provides us with a helpful processing of XQuery queries, however, it needs to be slightly modified to suit our case. The processing writes its result to a file in an XML representation. Instead of that, we need to keep the result in memory and pass it to consecutive steps of our algorithm. Though, this requirement concerns modifications of implementation while the core of the processing remains untouched. Therefore, we also do not describe these modifications.

Since we only modified the implementation of the output representation, the design of the syntax tree remains consequent to the entire design of the processing. Each node represents a logical component of a query. Inner nodes stand for XQuery constructs that are composed of other constructs and can be further devided. Examples of such constructs are FLWORs, if-than-else and function calls. Leaf nodes represents elements of XQuery language that can be devided no more. Typical representants are literal constants. \todo{zistit, ci konstanty nahodou nie su jedine}.

\todo[inline]{priklad stromu}
\todo[inline]{niekam popisat celu moznu strukturu stromu - najskor do appendixu}

\section{Inference of Built-in Types}
Prejst kazdy vyraz a ak z neho vieme nieco odvodit, tak to urobime.

Odvodit nieco vieme ak:
Nejaky podvyraz je path expression (alebo ine urcenie uzlu alebo hodnot uzlov \todo{toto domysliet}
a zaroven cely vyraz
1) je function call a podvyraz je jeho parameter a typ tohoto parametra vieme odvodit z hlavicky funkcie
2) je aritmeticka operacia a podla typov operandov vieme urcit typ podvyrazu (tj napriklad sa uzly porovnavaju s konstantou 5) \todo{co vsetko?}
3) dalsie konstrukcie ako cast as, type constructor, ... \todo{potrebuje riesit? princip je uplne rovnaky}



\begin{algorithm}
\caption{Repair RW-XML tree}
\label{propAlgo}
\begin{algorithmic}[1]
\REQUIRE $queryTrees$: A list of input query trees
\ENSURE Uzly a ich typy nejakym sposobom

\STATE initializacia nodeTypes
\FORALL{$queryTree \in queryTrees$}
    \STATE $partialNodeTypes = processQueryTree(queryTree)$
    \STATE $nodeTypes = mergeNodeTypes(nodeTypes, partialNodeTypes)$
\ENDFOR
\RETURN $nodeTypes$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Process arithmetic comparison}
\label{algorithm_process_arithmetic comparison}
\begin{algorithmic}[1]
\REQUIRE $expr$: An expression which is an arithmetic comparison
\ENSURE Uzly a ich typy nejakym sposobom

\STATE initializacia nodeTypes
\RETURN $nodeTypes$


\WHILE{$resultRXT \not \models_w \mathcal{FD}$}
    \STATE $S = \emptyset$ \COMMENT Set of repair groups
    \FORALL{$(F: S \rightarrow p) \in \mathcal{FD}$ s.t. $RXT \not \models_w F$}
    	\FORALL{$t_1, t_2$ tuples of $RXT$ s.t. $t_1, t_2$ do not weakly satisfy $F$}
		    \STATE $S = S \cup computeRepairGroup(F, t_1, t_2, RXT, S)$
	    \ENDFOR
    \ENDFOR

    \STATE $R = getRepair(S, RXT)$
    \STATE $resultRXT = applyRepair(R, resultRXT)$
\ENDWHILE
\end{algorithmic}
\end{algorithm}