\chapter{Analysis of XQuery}
\todo[inline]{bibref na knihu, a W3C XQuery usecases}
This chapter discusses selected constructs of XQuery language and denotes how they could be exploited in the XML schema inference process. It is divided into sections by particular domains of the inference.

\section{Structure of XML documents}
The most queries can be exploited to obtain some information about a structure of respective XML documents. The structure of XML documents captures elements from these documents along with their names, attributes and their organization. What are the outermost elements in these document, which elements can be contained inside a certain element, whether are they optional or mandatory, etc.

Path expressions without predicates which use only child axis are the simpliest example of such queries. Path expression \texttt{/bib/book/author} indicates element \texttt{bib} is the outermost element and contains one or more elements \texttt{book} and these contains one or more elements \texttt{author}.

Additional path expressions \texttt{/bib/book/title}, \texttt{//author/name} indicate that element \texttt{book} also contains element \texttt{title} and element \texttt{author} contains element \texttt{name}. The latter one uses also descendant axis.

Besides elements, attributes could be processed exactly the same way. Path expression \texttt{/bib/book/@ISBN} indicates that element \texttt{book} has attribute \texttt{@ISBN}.

However statemets of this kind are necessary for the XML schema inference, their obtaining from queries it not significant because of the following reason. These statement could be determined directly from the XML documents and it could be easily done in a more convenient way. Queries may not cover the whole relevant content of the documents. For example some element may not be queried at all, therefore they mat not be mentioned in any query. In addition, these statements do not express any obligation of occurrence of elements and attributes or possible multiple occurence of elements. At last, we cannot be sure that queries target nodes actually presented in the XML documents. Although query \texttt{/bib/book/author} indicates that element \texttt{author} is contained in element \texttt{book}, the query is valid whether this is true or not. In opposite, even basic methods of XML documents analyzis do not have these inadequacies.

On the other hand, the structure inference could be useful when the whole set of all XML documents is not available and provided XML documents do not cover the structure completly.

\section{Occurrence Count of Elements}
Some XQuery constructs indicate multiplicity of a particular element or limit the element to occur at most once. Consider the following query assuming variable \texttt{\$book1} is bound to a certain \texttt{book} element.

\begin{verbatim}
for $a in $book1/author 
order by $a/last, $a/first
return $a
\end{verbatim}

Apparently, this query expects more than one element \texttt{author} to be children of the element variable \texttt{\$book1} is bound to. Otherwise, any sorting would lack a reason. Although, we cannot be absolutely sure about it again, assuming common sense usage of XQuery it is very likely that element \texttt{author} can occur multiple times as a subelement of element from variable \texttt{\$book1}.

\subsection{Multiple Occurrence}
Similar approach could be applied in many other situations. Another examples are particular usages of function \texttt{count()}, indexation, usage of set operators (\texttt{union}, \texttt{intersect}, \texttt{except}) and usage of function \texttt{one-or-more()}. Queries with description follows.

\begin{verbatim}
<section_count>{ count(/book/section) }</section_count>
\end{verbatim}

Function \texttt{count()} returns number of items in a provided sequence. If the sequence is sequence of elements the count of these elements will probably not be limited to one. The example query indicates that the outermost element \texttt{book} can contain more than one element \texttt{section}.
An exception is usage of function \texttt{count()} in a predicate in expressions where it is used to determine if count of some nodes is greater than zero. Often, this form is used to test presence of a certain node instead of actual counting of its occurrences. In this case, the node could be still limited to occur at most once.

\begin{verbatim}
($s/incision)[2]/instrument
($s/instrument)[position()>=2]
\end{verbatim}

Indexation of nodes and common usage of function \texttt{position()} suggest that writer of such query assumes sequence of respective nodes.

\begin{verbatim}
one-or-more(/catalog/product[@id = 5]/color)
\end{verbatim}

In this query, number of elements \texttt{color} in element \texttt{product} with attribute \texttt{id} equal to 5 has to be at least one otherwise an error is raised upon execution. If we assume that this query is written correctly, with common sense and should not raise the error, we can infer that element \texttt{product} has to containt one or more elements \texttt{color}

\subsection{Occurrence Limited to One}
In opposite to the multiple occurrence, numerous XQuery constructs limit number of occurrences of an element to at most one or exactly one. Some example queries with description follow.

\begin{verbatim}
/catalog/product[1]/number lt 10
\end{verbatim}

\texttt{lt} is a representant of so called \emph{value comparison operators} which operate two sequences of zero or one item. If an operand of a \emph{value comparison operand} is sequence of more than one item \emph{type error} is raised.

\begin{verbatim}
for $item in //item 
order by $item/num 
return $item
\end{verbatim}

Alike the previous example, expression in \texttt{order by} clause can be evaluated to at most one item or the \emph{type error} is raised. Therefore, every element \texttt{item} contains zero or one element \texttt{num} but no more.

Another similar examples are arithmetic expressions and functions accepting a sequence of at most one item. Functions \texttt{zero-or-one()} will raise the \emph{type error} when supplied with an sequence of more than one item.

Those are constructs indicating limitation to zero or one occurrence. Function \texttt{exactly-one} works similar to the function \texttt{zero-or-one} but accepts only sequences of exactly one item (which are in XQuery equal to this item itself).

\section{Element and Attribute Types}

\subsection{XML Schema Built-in Types}
XML Schema built-in types of elements and attributes can be inferred from the XML documents by analysing their content. Since the count of built-in types is 44 and inheritance is involved, such analysis may be imprecise especially when a large enough set of XML documents is not available. \todo[inline]{priklad?} This is when a set of XQuery queries may be handy.

If a value of an element or attribute is used in an expression then this expression could be often exploited to determine a type of the value. Comparing the value to another value of a known type and supplying the value to a function call as an argument of particular type are examples of these expressions as shown below.

\begin{verbatim}
\\event\date = current-date()

\catalog\product\price < 24.5

declare function local:byteFunction($arg as xs:byte) as xs:byte
{...};
\catalog\product\local:byteFunction(@id)
\end{verbatim}
\todo[inline]{overit, ci su priklady OK}

Determined types are \texttt{xs:date} for element \texttt{date}, \texttt{xs:decimal} for element \texttt{price} and \texttt{xs:byte} for attribute \texttt{id}.

Alongside common expressions, there are other XQuery constructs indicating types as \emph{type casting}, \emph{constructors} and so called \emph{type declarations}.

Assuming variable \texttt{\$var} bound to a value of some element or attribute, following two fractions of queries indicate its type to be \emph{xs:integer}.

\begin{verbatim}
$var cast as xs:integer
xs:integer($var)
\end{verbatim}

The latter one is usage of \emph{type casting}, the former one is \emph{type constructor}.

Alike, following two examples of \emph{type declarations}. Value of element \texttt{number} is declared to be of type \texttt{xs:integer}.

\begin{verbatim}
every $number as element(*,xs:integer) in //number satisfies ($number > 0) 

declare variable $firstNumber as xs:integer 
:= data(//product/number[1]); 
\end{verbatim}

Although, determining built-in types of elements and attributes in simple queries may seem quite straightforward, reliable method would face some issues. More complex queries are commonly branched by \emph{if-then-else} construct. These branches can contain several contradictionary fragments from the view of type inference. Therefore, the reliable method would take the query structure into consideration and futher research would be needed.

\subsection{Enumeration}
In several cases, XQuery construct \emph{if-then-else} may be used to branch the execution of query by all posible values of a certain variable. This is equivalent of \emph{switch} construct from other programming languages. When the control variable is bound to some element or attribute, type of this node can be inferred as enumeration and its individual values can be determined as well.

\begin{verbatim}
Query
let $cat := doc("catalog.xml")/catalog 
for $dept in distinct-values($cat/product/@dept) 
return <li>Department: {if ($dept = "ACC") 
                        then "Accessories" 
                        else if ($dept = "MEN") 
                             then "Menswear" 
                             else if ($dept = "WMN") 
                                  then "Womens" 
                                  else () 
  } ({$dept})</li> 

Results 
<li>Department: Womens (WMN)</li> 
<li>Department: Accessories (ACC)</li> 
<li>Department: Menswear (MEN)</li> 
\end{verbatim}

Finding such patterns in queries could be useful in combination with analysis of XML data this queries are executed upon. XML data could help to confirm or disprove this assumption based on the query analysis of vice-versa.