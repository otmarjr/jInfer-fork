\chapter{Proposed Algorithm}
\todo[inline]{Nejaky uvod a zkratke hrnutie}
\todo[inline]{Predpoklad korektnosti dotazov}

\section{Step 1: Construction of a Syntax Tree}
The first step of the algorithm involves lexical and syntax analyses known from the construction of compilers and produces a so-called syntax tree. The analyses are taken from Ji\v r\'{i} Schejbal's master thesis \todo{ref}. Since they are not directly related to the inference, and thus, they are not directly related to the topic of this thesis, we will not describe them. Nevertheless, they provides us with a helpful processing of XQuery queries and we can focus on the inference.

The syntactic analysis needs to be slightly modified to suit our case. It writes its result into a file in an XML representation. Instead, we need to keep the result in the main memory and pass it to consecutive steps of our algorithm. Though this requirement concerns modifications of implementation, the core of the processing remains untouched. Therefore, we also do not describe these modifications.

\subsection{Definition of the Syntax Tree}
Firstly, we formally define the syntax tree.

\begin{define}[Syntax tree]
\label{DEF_syntax_tree}
Syntax tree of XQuery query $Q$ is tuple $T = (V, E, c, \mathcal{P}, o)$ where
\begin{itemize}
\item $V \subset \mathbb{N}$ is a set of nodes, each node representing a particular XQuery construct in query $Q$,
\item $E$ is a set of pairs $(v, w)$ where $v,w \in V$ and for every $a, b \in V, a \neq b: (a, b) \in E$ if and only if a construct represented by $b$ is a direct component of a construct represented by $a$ ($b$ is a child of $a$) in query $Q$,
\item $c: V \rightarrow C$ is function assigning each node with its class from set $C$ of all XQuery language constructs listed in Figures \ref{FIG_syntax_tree_node_types_part_1}, \ref{FIG_syntax_tree_node_types_part_2},
\item $\mathcal{P}$ is a set of functions specifying additional properties of the nodes and distinguishing the nodes of the same classes,
\item and $o : V \rightarrow \mathcal{O}$ is a function specifying an order of children of the nodes, where $\mathcal{O} = \{o_v : E_v \rightarrow \mathbb{N} | v \in V, E_v = \{(v, w) | w \in V, (v,w) \in E\}\}$ is set of functions specifying the children order for each node. For every $v \in V, o(v) = o_v$ so that $o_v(v,w)$ is a sequential number of a construct represented by $w$ amongst constructs represented by children of $v$ in query $Q$.
\end{itemize}
\end{define}

Regarding the additional properties, two constructs in $Q$ represented by two nodes of the same class from $C$ may differ in certain ways, and therefore, it is needed to distinguish them. For instance, two different literal values in $Q$ are represented by nodes $l_1, l_2 \in V$ and $c(l_1) = c(l_2) = LiteralNode$ but each has a different value and type. Therefore $\mathcal{P}$ contains functions \\
$type_{LiteralNode}: V_{LiteralNode} \rightarrow Types_{literal}$ \\
$value_{LiteralNode}: V_{LiteralNode} \rightarrow Values_{literal}$ \\
where $V_{LiteralNode}$ is set $\{v | v \in V, c(v) = LiteralNode\}$, $Types_{literal}$ is set of all types of literal values $\{DECIMAL, INTEGER, DOUBLE, STRING\}$, and $Values_{literal}$ is a set of all literal values (all valid XQuery decimal numbers, integers, double numbers and strings).

Set $\mathcal{P}$ contains other similar functions but due to their large number, we do not define them formally.
\todo[inline]{Q: Moze takto ostat, alebo definovat aspon tie co pouzivame? Alebo ich aspon vypisat? A: aspoň příklad, lépe vypsat ty, co použijeme}

\todo[inline]{Hodil by se příklad stromu - jeslti nebude dál.}

\subsection{Syntactic Abbreviations}
Since we need to use the syntax tree in pseudo-algorithms, we define the following abbreviations to make its usage more simple.

For every $v \in V$, abbreviation
\begin{itemize}
\item $v.p$ stands for $p_{c(v)}(v)$ if $p_{c(v)} \in \mathcal{P}$.
\item $v.getChildren()$ stands for $\{w | w \in V, (v,w) \in E\}$ which is a set of all children of $v$.
\item $v.getChild(i)$, $i \in \mathbb{N} \cup \{0\}$, stands for $w \in V$ so that $o(v)(v,w) = i + 1$.
\item $v.getChild(class), class \in C$, stands for $w \in V$ so that $(v,w) \in E$ and $c(w) = class$, if $\Bigl | \{u | u \in V, (v,u) \in E, c(u) = class\}\Bigr | = 1$.
\end{itemize}

\todo[inline]{Q: Je nutne presnejsie popisat kedy a preco tieto skratky maju zmysel? V pseudo-kodoch budu samozrejme pouzivane len v pripadoch, ked su dobre definovane a maju zmysel. A: Ne, ale hodilo by se slovně popsat co znamenají.}

\subsection{Closer Look at the Nodes of the Syntax Tree}
The node classes of the syntax are organized in an is-a hierarchical structure, commonly used in the object oriented programming languages, where an object can be of several types. This hierarchy is shown in tables in Figures \ref{FIG_syntax_tree_node_types_part_1}, \ref{FIG_syntax_tree_node_types_part_2}. The tables are composed of classes in italic and their subclasses. The classes with names in bold represent a common class of a group of subclasses, and these classes cannot be directly used in the syntax tree (abstract classes). The remaining non-bold nodes represent particular constructs of the XQuery language and nodes of these classes can be used in the syntax tree. 

For example, an instance of the syntax tree cannot directly contain nodes of $Node$ and $ExprNode$ classes (for every $v \in V, c(v) \neq Node, c(v) \neq ExprNode$), but it can contain nodes of $AttributeNode$ and $LiteralNode$ classes. Regarding the multiplicity of types, a node of $LiteralNode$ class is also considered to be of two indirect types: $ExprNode$ and $Node$.

\todo[inline]{Q: Asi bude potrebne nakreslit pre kazdy node, co presne obsahuje. Alebo staci pre tie, ktore budeme my pouzivat? A: Určitě všude stačí popsat jen to, co použijeme, s poznámkou, že zbytek je např. v diplomce, ze které vycházíte.}

The node classes can be classified into three groups: inner node classes, leaf node classes and node classes that can be both inner and leaf. Inner node classes (marked $I$) stand for XQuery constructs that are composed of other constructs and can be further divided. An example of such class is $FLWORExprNode$ which is composed of $TupleStreamNode$, $WhereClauseNode$, $OrderByClauseNode$ and $ReturnClauseNode$ classes. Leaf node classes (marked $L$) represent elements of XQuery language that cannot be further divided. For example, $LiteralNode$. Node $FunctionCallNode$ is an example of the third group (marked $IL$). Function call of a function without arguments is represented by a leaf node while function call with arguments is represented by an inner node and its subnodes are nodes representing those arguments.

\begin{figure}
\caption{Syntax tree node types part 1.}
\label{FIG_syntax_tree_node_types_part_1}
\begin{tabular}{l l | l}
\multicolumn{2}{l|}{\textbf{\emph{Node}}} & \textbf{\emph{ExprNode}} \\
\hline
AttributeNode (I) & ModuleNode (I) & CommaOperatorNode (I) \\
AttrListNode (IL) & NameNode (IL) & ConstructorNode (I) \\
AxisNode (I) & OrderByClauseNode (I) & ContextItemExprNode (L) \\
CaseClauseNode (I) & OrderSpecNode (I) & EmptySequenceNode (L) \\
CaseClausesNode (I) & ParamListNode (I) & ExtensionExprNode (I) \\
CDataSectionNode (L) & ParamNode (I) & FLWORExprNode (I) \\
ContentNode (IL) & PITargetNode (IL) & FunctionCallNode (IL) \\
DefaultCaseNode (I) & PragmaListNode (I) & IfExprNode (I) \\
EntityRefNode (L) & PragmaNode (L) & LiteralNode (L) \\
\textbf{ExprHolderNode} & PredicateListNode (I) & OperatorNode (I) \\
\textbf{ExprNode} & \textbf{PrologChildNode} & OrderedExprNode (I) \\
FunctionBodyNode (IL) & StepExprNode (I) & PathExprNode (I) \\
CharRefNode (L) & StringNode (L) & QuantifiedExprNode (I) \\
InClausesNode (I) & TupleStreamNode (I) & TypeswitchExprNode (I) \\
\textbf{ItemTypeNode} & TypeNode (L) & UnorderedExprNode (I) \\
LocationHintNode (L) & \textbf{VariableBindingNode} & ValidateExprNode (I) \\
LocationHintsNode (IL) & VarValueNode (IL) & VarRefNode (L) \\
\textbf{ModuleChildNode} & & \\
\end{tabular}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 2.}
\label{FIG_syntax_tree_node_types_part_2}
\begin{tabular}{l | l}
\textbf{\emph{PrologChildNode}} & \textbf{\emph{ExprHolderNode}} \\
\hline
BaseURIDeclNode (L) & BindingSequenceNode (I) \\
BoundarySpaceDeclNode (L) & DefaultValueNode (I) \\
ConstructionDeclNode (L) & ElseExpressionNode (I) \\
CopyNamespacesDeclNode (L) & OperandExpressionNode (I) \\
DefaultCollationDeclNode (L) & ReturnClauseNode (I) \\
DefaultNamespaceDeclNode (L) & TestExpressionNode (I) \\
EmptyOrderDeclNode (L) & ThenExpressionNode (I) \\
FunctionDeclNode (I) & WhereClauseNode (I) \\
\cline{2-2} \textbf{ImportNode} & \textbf{\emph{ItemTypeNode}} \\
\cline{2-2} NamespaceDeclNode (L) & AnyItemNode (L) \\
OptionDeclNode (L) & AtomicTypeNode (L) \\
OrderingModeDeclNode (L) & KindTestNode (IL) \\
VarDeclNode (I) & NameTestNode (L) \\
\cline{1-2} \textbf{\emph{ImportNode}} & \textbf{\emph{VariableBindingNode}} \\
\cline{1-2} ModuleImportNode (I) & ForClauseNode (I) \\
SchemaImportNode (I) & InClauseNode (I) \\
\cline{1-1} \textbf{\emph{ModuleChildNode}} & LetClauseNode (I) \\
\cline{1-2} ModuleDeclNode (L) & \emph{StepExprNode} (I) \\
\cline{2-2}PrologNode (IL) & SelfOrDescendantStepNode (L) \\
QueryBodyNode (I) & 
\end{tabular}
\end{figure}

Some pseudo code algorithms in the following sections need to determine a class of a node. The node's direct class can be determined by function $c$ from the definition of the syntax tree in Definition \ref{DEF_syntax_tree}, and hence, we also can determine its indirect classes. For the purpose of pseudo code, we define the following function.

\begin{define}[Function is(v, class)]For every $v \in V$ and every $class \in C$, function $is(v, class)$ returns boolean value $true$ if $c(v) = class$ or $c(v)$ is a (direct or indirect) subclass of $class$, according to the described principle. Otherwise, it returns $false$.
\end{define}

For instance, assuming $v \in V, c(v) = LiteralNode$, calls $is(v, LiteralNode)$, $is(v, ExprNode)$ return $true$, while call $is(v, ContentNode)$ returns $false$.

\subsection{Characteristics of the Syntax Tree}
An important characteristic of the syntax tree is related to a definition of local variables and their scope in the XQuery language. The representation of a definition of a local variable in the syntax tree is a node of $VariableBinding$ class. Nodes of that class have only two children; a node representing the type of the variable and a node representing the binding expression (expression defining the value of the variable, and thus, it cannot use the variable). Hence, the entire subtree does not contain any expressions that use the variable. Therefore the scope of the new variable is not the subtree of the $VariableBinding$ class node. It depends on the type of XQuery construct that the variable binding is a (indirect) component of.

For example, a node of $FLWORExpr$ class contains four subnodes of\linebreak $TupleStream$, $WhereClause$, $OrderByClause$ and $ReturnClause$ classes. The $TupleStream$ class node contains a list of node of $variableBinding$ class which define variables valid in all other three subnodes of the FLWOR node.

\todo[inline]{Nejak sa z tohoto vytratilo to, preco to je pre nas dolezita charakteristika}

\todo[inline]{priklad stromu}

\section{Step 2: Static Analysis of Expression Types}
In the second step, we statically (i.e. without evaluation of the queries) determine types of expressions in the syntax tree. Information on the types of expressions can be used by consecutive steps of the algorithm. The consecutive steps will not use the determined types of all expressions, however this step may be useful in a future extending.

The analysis of expression types can be divided into three substeps. Determination of return types of functions, determination of types of global variables, and finally determination of types of expressions.

But firstly, we describe types of expressions we want to capture and their features.

\subsection{Expression Types}

\begin{itemize}
\item XML Schema built-in atomic types \todo{link do appendixu}.
\item Types $ElementType$, $AttributeType$, $NodeType$, $TextNodeType$,\linebreak $CommentType$, $ProcessingInstructionType$, $DocumentType$ representing an element, attribute, node, text node, comment, processing instruction, document node.
\item Type representing a node or a set of nodes selected by a certain path expression. The path expression is included in this type. Let this type be identified as $PathType$.
\item $UnknownType$ representing a type without known details, which does not suit one of the three previous types. An example is XSD type $anyType$.
\end{itemize}

\subsection{PathType}
$PathType$ contains additional information. The represented path is contained by a list of its steps, in particular instances of $StepExprNode$. If a step is a reference to a variable which type is $PathType$, we also want to include this information. Therefore, $PathType$ contain association between the steps and other $PathTypes$ and this association is defined for the $PathType$ variable steps.

To differ between a common $PathType$ selecting a set of nodes and a $PathType$ bound to a for variable in a FLWOR expression, $PathType$ structure contains a flag $isForBound$.

Additionaly, $PathType$ contains a list of special functions that were called with an argument of $PathType$ type. The motivation is that in some cases of function calls, we want to know that the function call is performed with an instance of $PathType$ because then, we can determine a type of the function call more precisely. Those special functions are built-in functions $data$, $min$, $max$ \todo{Doplnit}.

In summary, we represent $PathType$ as a structure with the following member variables. \todo{Radsej UML?}
\begin{itemize}
\item $stepNodes$ - A list of references to $StepExprNode$ instances.
\item $forBoundSubsteps$ - An association between references from $stepNodes$ and instances of $PathType$ type.
\item $isForBound$ - Boolean flag determining if the type was bound to a for variable in a for clause.
\item $specialFunctionCalls$ - List of special functions called with this instance as an argument.
\end{itemize}

\subsection{Cardinality of Types}

To capture sequences, we assign the first two categories of types (all types except of $PathType$ and $UnknownType$) with its cardinality as proposed in \todo{ref na Schajbalovu diplomku}. Each of those types can be perceived as a sequence. A type representing one value or one item can be perceived as a sequence of exactly one item. The cardinality expresses one of the following five sequence types.

\begin{itemize}
\item An empty sequence.
\item A sequence of exactly one item.
\item A sequence containing zero or one item (modifier $?$).
\item A sequence containing zero or more items (modifier $*$).
\item A sequence containing one or more items (modifier $+$).
\end{itemize}

$PathType$ is not assigned with the cardinality since we do not evaluate the queries, and therefore, we cannot determine if a certain XQuery path targets zero, one or more nodes. Alike, $UnknownType$ is neither assigned with the cardinality. Expressions of $UnknownType$ are not utilized it the inference, therefore, their cardinality is not needed.

\todo[inline]{Este by sa dala urobit analyza volania funkcii, do ktorych su predavane nejake elementy/atributy o ktorych vieme ich path expression. Vysledkom tejto funkcie by totiz zas mohli byt elementy/atributy o ktorych vieme (pozmenenu) path expression a nie len nezname elementy/atributy.
A: Přesně tak. A jak říkám - není třeba vše co navrhnete implementovat.
A2: Stačí to popsat a v kapitole Implementace říct, které ásti algoritmu implementujeme. Stačí takové, které už ukáží zajímavé chování a dokážou přínosy návrhu. Přesně k tomu implmentace je.}

\subsection{Determination of Function Return Types}
Determination of return types of functions is needed because function calls can appear in expressions. A return type of a function can be determined at the moment the analysis of expressions encounters a call of the function; however, it involves multiple transitions of the syntax tree in a search for a definition of a particular function.

Instead, the syntax tree can be searched just once, before the analysis of expressions, and return types of all functions found are stored.

\begin{algorithm}
\caption{Retrieval of Function Declaration Nodes $getFunctionDeclarationNodes(syntaxTree)$}
\label{ALG_retrieval_of_function_declaration_nodes}
\begin{algorithmic}[1]
\REQUIRE $syntaxTree$: A reference to the root node of a syntax tree.
\ENSURE A list of syntax tree nodes representing function declarations.

\STATE $prologNode = null$
\FORALL{$moduleChildNode \in syntaxTree.getChildren()$}
    \IF{$is(moduleChildNode, PrologNode)$}
        \STATE $prologNode = moduleChildNode$
    \ENDIF
\ENDFOR

\STATE $functionDeclarationNodes =$ an empty list
\IF{$prologNode \neq null$}
    \FORALL{$prologChildNode \in prologNode.getChildren()$}
        \IF{$is(prologChildNode, FunctionDeclNode)$}
            \STATE add $prologChildNode$ to $functionDeclarationNodes$
        \ENDIF
    \ENDFOR
\ENDIF

\RETURN $functionDeclarationNodes$
\end{algorithmic}
\end{algorithm}

A simple algorithm is presented in Algorithm \ref{ALG_processing_of_functions}. It uses \texttt{getFunction\-DeclarationNodes()} function, defined in Algorithm \ref{ALG_retrieval_of_function_declaration_nodes}, which returns a list of all function declaration nodes in the syntax three. Actually, it does not have to search the whole syntax tree as the function declaration nodes can be present only in the query prolog section. 

Without loss of generality, we will focus on locally defined functions. We will not determine types of functions defined in other modules since the principle is similar but it is needed to look up the definitions in syntax trees of other queries. Return types of built-in functions are fixed and, thus, there is no need to analyze them.

\begin{algorithm}
\caption{Processing of Functions}
\label{ALG_processing_of_functions}
\begin{algorithmic}[1]
\REQUIRE $syntaxTree$: A reference to the root node of a syntax tree.
\ENSURE An associative array of function names with their types and references to the their declaration nodes.

\STATE $functionArray$ = an empty associative array
\FORALL{$functionDeclarationNode \in$ \\ $getFunctionDeclarationNodes(syntaxTree)$}
    \STATE $functionName = functionDeclarationNode.funcName$
    \STATE $typeNode = functionDeclarationNode.getChild(TypeNode)$
    \STATE $functionArray[functionName] =$ \\ $(getTypeTN(typeNode), functionDeclarationNode)$
\ENDFOR
\RETURN $functionArray$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Extraction of a Type from TypeNode getTypeTN()}
\label{ALG_extraction_of_a_type_from_typenode}
\begin{algorithmic}[1]
\REQUIRE $typeNode$: Syntax tree node of TypeNode class.
\ENSURE Type extracted from $typeNode$.

\STATE $type = null$
\STATE $cardinality = typeNode.cardinality$
\STATE $itemTypeNode = typeNode.getChild(ItemTypeNode)$
\IF{$is(itemTypeNode, AtomicTypeNode)$}
    \STATE $type = itemTypeNode.typeName$
\ELSIF{$is(itemTypeNode, KindTestNode)$}
    \STATE $type = itemTypeNode.nodeKind$
\ENDIF

\RETURN $type$, $cardinality$
\end{algorithmic}
\end{algorithm}

\todo[inline]{ALG Extraction of a Type from TypeNode nie uplne sedi s definiciou typov. DP JS ma nieco navyse. A tento alg je nedokonceny!!}

For the rest of the thesis, we assume function $getFunctionReturnType()$ which takes a function name and returns the return type of the function if the function is either built-in or it is recorded in the associative array. Otherwise, \texttt{null} is returned.

Later phases of the algorithm need to process the declarations of certain functions. Therefore, we also store references to the entire function declaration nodes, accessible using function $getFunctionDeclNode()$.

\subsection{Auxiliary Functions}
Before proceeding to the next phase of the algorithm, we introduce auxiliary functions used in pseudo algorithms.

Function $memorizeType()$ takes two arguments $node$ and $type$ and it memorizes the given type of the specified expression node. This information can be then retrieved by function $getType()$, specifying the particular node as its argument.

Another group consists of functions $set()$, $add()$, and $get()$. Function $set()$ memorizes a given value of a specified property of a specified node. It is used to assign a node with a named value, for example, $set(someNode, color, 'red')$ will assign $someNode$ with string value $'red'$ wich can be then retrieved by function $get()$, specifying the node and the property name. For example,\linebreak $get(someNode, color)$ returns $'red'$. A subsequent call of $set()$ assigning a node with a value of already assigned property will overwrite it, leaving the property with the newer value. However, a property can have several values and this can be achieved using function $add()$ with the same syntax as function $set()$ but instead of overwriting the existing property, $add()$ will append the new value to the existing ones. Then, a call of $get()$ on this node and property returns a list of all its values, preserving the order of their addition.

\subsection{Determination of Global Variable Types}
A similar approach as in the case of functions can be applied to determine types of global variables. Alike the functions, the global variables are defined in the prolog section. A type of a variable can be explicitly specified in its definition \todo{je to tak? priklad}. If it is not, it may often be deducible from the binding expression. Again, we do not analyse external variables for the same reason as in case of external functions.

\begin{algorithm}
\caption{Function determineExpressionType()}
\label{ALG_func_determineExpressionType}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $exprNode$: An expression node in the syntax tree. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}
\ENSURE The expression type.

\STATE $type = null$
\IF{$is(exprNode, LiteralNode)$}
     \STATE $type =$ XSD atomic type $exprNode.type$, exactly-once cardinality
\ELSIF{$is(exprNode, FunctionCallNode)$}
     \STATE $type = getFunctionReturnType(exprNode.fncName)$
\ELSIF{$is(exprNode, VarRefNode)$}
     \STATE $type = getVariableType(contextVarTypes, exprNode.varName)$
\ELSIF{$is(exprNode, PathExprNode)$}
     \STATE $type = createPathType(exprNode)$
\ELSIF{$is(exprNode, OperatorNode)$}
     \STATE $type = determineOperatorType(exprNode, contextVarTypes)$
\ELSIF{$is(exprNode, FLWORExprNode)$}
     \STATE $returnClauseNode = exprNode.getChild(ReturnClauseNode)$
     \STATE $type = createForUnboundType(getType(returnClauseNode))$
\ENDIF

\RETURN $type$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function determineOperatorType()}
\label{ALG_func_determineOperatorType}
\begin{algorithmic}[1]
\REQUIRE{\ \\ 
    $operatorNode$: An operator expression node in the syntax tree. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}
\ENSURE The operator expression type.

\STATE $type = null$
\STATE $operator = operatorNode.operator$
\IF{$isOperatorClassComparison(operator)$}
    \STATE $type = xs:boolean$, exactly-one cardinality
\ELSIF{$isOperatorClassAddition(operator)$}
    \STATE $leftOperandType = getType(exprNode.leftSide)$
    \STATE $rightOperandType = getType(exprNode.rightSide)$
    \IF{$isNumericType(leftOperandType)$ $AND$ $isNumericType(rightOperandType)$}
        \STATE $type = selectMoreGeneralNumericType(leftOperandType,$ $rightOperandType)$
    \ELSIF{$isNumericType(leftOperandType)$}
        \STATE $type = leftOperandType$
    \ELSIF{$isNumericType(rightOperandType)$}
        \STATE $type = rightOperandType$
    \ENDIF
\ENDIF

\RETURN $type$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function isOperatorClassComparison()}
\label{ALG_func_isOperatorClassComparison}
\begin{algorithmic}[1]
\REQUIRE $operator$: Representation of a XQuery operator.
\ENSURE $true$ if $operator$ is a comparison operator, $false$ otherwise.

\IF{$operator$ equals one of $GEN\_EQUALS$, $GEN\_GREATER\_THAN$, $GEN\_GREATER\_THAN\_EQUALS$, $GEN\_LESS\_THAN$, $GEN\_LESS_THAN\_EQUALS$, $GEN\_NOT\_EQUALS$, $VAL\_EQUALS$, $VAL\_GREATER\_THAN$, $VAL\_GREATER\_THAN\_EQUALS$, $VAL\_LESS\_THAN$, $VAL\_LESS\_THAN\_EQUALS$, $VAL\_NOT\_EQUALS$}
    \RETURN $true$
\ELSE
    \RETURN $false$
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function isOperatorClassAddition()}
\label{ALG_func_isOperatorClassAddition}
\begin{algorithmic}[1]
\REQUIRE $operator$: Representation of a XQuery operator.
\ENSURE $true$ if $operator$ is an addition operator, $false$ otherwise.

\IF{$operator$ equals one of $PLUS$, $MINUS$}
    \RETURN $true$
\ELSE
    \RETURN $false$
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function isNumericType()}
\label{ALG_func_isNumericType}
\begin{algorithmic}[1]
\REQUIRE $type$: Representation of a type.
\ENSURE $true$ if $type$ represents one of the XSD atomic built-in numeric types, $false$ otherwise.

\IF{$type$ represents one of $float$, $double$, $decimal$, $integer$, $long$, $int$, $short$, $byte$, $nonPositiveInteger$, $negativeInteger$, $nonNegativeInteger$, $positiveInteger$, $unsignedLong$, $unsignedInt$, $unsignedShort$, $unsignedByte$}
    \RETURN $true$
\ELSE
    \RETURN $false$
\ENDIF
\end{algorithmic}
\end{algorithm}

The algorithm iterates through the variable declaration nodes from the prolog and if the variable is explicitly assigned with its type, the type is noted. Otherwise, an attempt of the type deduction of the binding expression is made. The deduction of the type from the expression is presented in Algorithm \ref{ALG_func_determineExpressionType}. On input, it takes an expression node and types of local variables that are valid in the expression (also called context of variables or variable context). The presented algorithm is just shortened illustration since the complete version is too long to be presented in this text. Nevertheless, the principle is straightforward. Depending on the class of the expression node (show in Figure \ref{FIG_syntax_tree_node_types_part_4}), its type can be either determined directly or it depends on its subexpressions. A part of the function's semantic is separated in Algorithm \ref{ALG_func_determineOperatorType}, which is not presented completely because of the same reason.

Function $determineExpressionType$ is called within function $analysis\-Of\-Expression\-Types$ presented in Algorithm \ref{ALG_func_analysisOfExpressionTypes}, which recursively determines types of all subexpressions. Two important questions about this function emerge. How (in which order) are the tree nodes recursively processed and how does the function handle definitions (bindings) of new variables which may also appear in the expressions?

The order of the recursion is to firstly process children of a node and then the node itself. The order of child processing is specified by function $o$ from the definition of the syntax tree in Definition \ref{DEF_syntax_tree}. The reason is that an expression node may need to know types of its subexpressions to determine its own type and we want to determine types of all expressions. Therefore, using the described order, subexpressions of an expression are processed first, and then the expression itself without any need for further recursion, because the types of the subexpressions are already determined.

The handling of new variable definitions relies on the fact that the definitions make the new variables valid only in nodes with a higher sequence number when numbered in the order described in in the previous paragraph. Therefore, the left-most (the first amongst the ordered subnodes) subnode of a certain node can be processed without an extension of the variable context. And, if the left-most subnode extends the variable context for the following nodes in the numbering, it can be easily handled because the types of the new variables can be directly determined since the binding expressions are already processed (thus, their types are known). Every node ''knows'' wheather or not it may define new variables for nodes with higher sequence numbers. This is expressed in the algorithm by the condition stating at line 10. If it does define new variables, they are memorized. Later, upon processing of its parent, they are retrieved and the variable context is extended. This is done at lines 4 and 5. Function $mergeContextVarTypes$ presented in Algorithm \ref{ALG_function_mergeContextVarTypes} writes every record from its second argument (the new variables) into its first argument (the variable context). If there are records for variables with the same names in the context, they are overwritten to correspond to the variable overlapping. It is important to note that we assume the variable context is not passed by reference but by value, and hence, the variable context of a certain node is not affected by the recursive processing of its subnodes.

\begin{algorithm}
\caption{Function analysisOfExpressionTypes}
\label{ALG_func_analysisOfExpressionTypes}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $startingNode$: A node determining a subtree to perform the analysis on. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}

\FORALL{$i \in \{1, \dots, |startingNode.getChildren()|\}$ ordered from the lowest to the highest}
    \STATE $subnode = startingNode.getChild(i)$
    \STATE $analysisOfExpressionTypes(subnode, contextVarTypes)$ \COMMENT{recursion}
    \STATE $newVars = get(subnode, newVars)$    
    \STATE $contextVarTypes = mergeContextVarTypes(contextVarTypes, newVars)$
\ENDFOR
\IF{$is(startingNode, ExprNode)$}
    \STATE $memorizeType(startingNode, determineExpressionType(startingNode))$
\ENDIF
\IF{$is(startingNode, VariableBindingNode)$}
    \STATE $type = null$
    \STATE $typeNode = startingNode.getChild(TypeNode)$
    \IF{$typeNode \neq null$}
        \STATE $type = getTypeTN(typeNode)$
    \ELSE
        \STATE $type = determineExpressionType(startingNode.$ $getChild(BindingSequenceNode).getChild(ExprNode),$ $contextVarTypes)$
        \IF{$is(startingNode, ForClauseNode)$}
            \STATE $type = createForBoundType(type)$
        \ENDIF
    \ENDIF
    \STATE $set(startingNode, newVars, (startingNode.varName, type))$
\ELSIF{$is(startingNode, TupleStreamNode)$}
    \FORALL{$varBindingNode \in startingNode.getChildren()$}
        \STATE $add(startingNode, newVars, get(varBindingNode, newVars))$
    \ENDFOR
\ENDIF
\end{algorithmic}
\end{algorithm}

\todo[inline]{Overit si, ci ALG \ref{ALG_func_analysisOfExpressionTypes} pokryva vsetky pripady, co sa tyka definovania novych premennych a ich propagacie vyssim uzlom.}

\todo[inline]{Pozor na to přetékání textu - na spoustě míst.}

\begin{algorithm}
\caption{Function mergeContextVarTypes}
\label{ALG_function_mergeContextVarTypes}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $keys()$: Function retrieving index values of an indexed structure. \\
    $contextVarTypes$: Types of local variables valid in current context. \\    
    $extendingVarTypes$: New variables in the same structure as the first argument.
}
\ENSURE The context variable types extended with the variable types from the second argument.

\FORALL{$varName \in keys(extendingVarTypes)$}
    \STATE $contextVarTypes[varName] = extendingVarTypes[varName]$
\ENDFOR
\RETURN $contextVarTypes$
\end{algorithmic}
\end{algorithm}

Function $analysisOfExpressionTypes$ called upon a binding expression of a global variable determines the type of the binding expression, and hence, the type of the variable. In case of global variables, the argument $contextVarTypes$ is empty, because there are no local variables valid in the prolog section.

\begin{algorithm}
\caption{Function getVariableType}
\label{ALG_function_get_variable_type}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $contextVarTypes$: Types of local variables valid in current context. \\
    $var$: A variable to determine the type of.
}
\ENSURE The type of variable $var$.

\IF{$contextVarTypes[var]$ is defined}
     \RETURN $contextVarTypes[var]$
\ELSE
     \RETURN $getGlobalVariableType(var)$
\ENDIF
\end{algorithmic}
\end{algorithm}

The types of processed global variables are available trough function \linebreak $getGlobalVariableType()$. If the function gets a variable that is not a global one, it returns $null$. Function $getVariableType()$ called in Algorithm \ref{ALG_func_determineExpressionType} is defined in Algorithm \ref{ALG_function_get_variable_type}. It checks if the specified variable is amongst the given local variables. If so, it returns its type, else it handles the variable as a global one and if such global variable does not exist the result is $null$.

\begin{algorithm}
\caption{Function createPathType}
\label{ALG_function_create_path_type}
\begin{algorithmic}[1]
\REQUIRE $pathExprNode$: A reference to a PathExprNode to create the PathType from.
\ENSURE The PathType of $pathExprNode$ expression.

\STATE $stepNodes =$ an empty array
\STATE $forBoundSubsteps =$ an empty associative array
\FORALL{$stepNode \in pathExprNode.getChildren()$}
	\STATE $detailNode = stepNode.getChild(ExprNode)$
	\IF{$detailNode != null$}
		\IF{$is(detailNode, VarRefNode)$}
			\STATE $type = getType(detailNode)$ // $PathType$
			\IF{$type.isForBound$}
				\STATE $forBoundSubsteps[stepNode] = type$
				\STATE add $stepNode$ to $stepNodes$
			\ELSE
				\STATE add all $type.stepNodes$ to $stepNodes$
			\ENDIF
		\ELSE
			\STATE add $stepNode$ to $stepNodes$
		\ENDIF
	\ELSE
		\STATE add $stepNode$ to $stepNodes$
	\ENDIF
\ENDFOR

\RETURN $PathType$ with $stepNodes$, $forBoundSubsteps$, and $isForBound$ set to $false$
\end{algorithmic}
\end{algorithm}

\subsection{Determination of Expression Types}
To determine types of expressions, we use already introduced function \linebreak $analysisOfExpressionTypes$. The starting node (its first argument) is the node representing the query body and the variable context is empty as there cannot be any local variable valid in the body node.

\begin{algorithm}
\caption{Function createForBoundType}
\label{ALG_function_create_for_bound_type}
\begin{algorithmic}[1]
\REQUIRE $type$: A type to create the for bound type from.
\ENSURE The for bound type from $type$.

\IF{$type$ is $UnknownType$}
	\RETURN $UnknownType$
\ELSIF{$type$ is $NodeType$ or XSD atomic type}
	\RETURN $type$ with cardinality set to exactly-one
\ELSE
	\STATE // $PathType$
	\RETURN $type$ with $isForBound$ flag set to $true$
\ENDIF
\end{algorithmic}
\end{algorithm}

We can also determine expression types in functions. To do this for a certain function, $analysisOfExpressionTypes$ function has to be called with a function declaration node as the starting node. In this case, the function declaration node contains a subnode specifying function's formal arguments. These argument are set as the variable context for the function body represented by another subnode.

\begin{algorithm}
\caption{Function createForUnboundType}
\label{ALG_function_create_for_unbound_type}
\begin{algorithmic}[1]
\REQUIRE $type$: A type to create the for unbound type from.
\ENSURE The for unbound type from $type$.

\IF{$type$ is $UnknownType$}
	\RETURN $UnknownType$
\ELSIF{$type$ is $NodeType$ or XSD atomic type}
	\RETURN $type$ with cardinality set to zero-or-more
\ELSE
	\STATE // $PathType$
	\RETURN $type$ with $isForBound$ flag set to $false$
\ENDIF
\end{algorithmic}
\end{algorithm}

\section{Step 3: Inference of Built-in Types}
In this step, the algorithm goes through the syntax tree to infer types of elements and attributes from expressions using the type information from the previous step. These two steps could be merged together but for better comprehension we present it separately.

How are the types inferred from the expression types? We do not exploit all expressions. Only expressions of a particular type are exploited. Specifically, an expression has to contain an subexpression $E$ of $PathType$ type (expression representing a certain element or attribute or set of elements or attributes). In the following text, the set represented by expression $E$ is denoted $S$. Another requirement is that the expression has to be either a function call or an arithmetic operation \todo{Q: Nejake ine ako napr type constructor, cast as? Princip je stale rovnaky. A: ak to jen popište. To je naprosto OK.}.

The output of this step is a set of couples ($pathType$, XML Schema built-in type).

\todo[inline]{Zlucovanie odvodenych tvrdeni.}
\todo[inline]{Path expressions s predikatmi.}

\subsection{Function Calls}
This case is quite straightforward. The algorithm encounters a function call and one of the arguments is a known set of elements of attributes (subexpression $E$ representing $S$). To determine the type of $S$, it is only needed to determine the type of the corresponding formal argument from the definition of the function. The function is either a built-in one so its definition is known or it is defined in the prolog section. External functions are not processed as was mentioned already.

If the type $T$ of the formal argument is a built-in type or its sequence, then $T$ is also the inferred type of $S$. Otherwise, no statement is inferred.

\subsection{Arithmetic Operations}
If the operator is one of $+$, $-$, $*$, $div$, $mod$ (the class of the expression node is $Operator$ and it represents one of $PLUS$, $MINUS$, $MUL$, $DIV$, $MOD$ \todo{Niekam napisat mozne triedy operatora}), one operand is $E$ and the type $T$ of the other operand is one of numeric built-in types, then $T$ is also the inferred type of $S$.

If the operator is one of $<$, $>$, $<=$, $>=$, $=$, $!=$ (the class of the expression node is $Operator$ and it represents one of $GEN\_LESS\_THAN$, \linebreak $GEN\_GREATER\_THAN$, $GEN\_LESS\_THAN\_EQUALS$,\linebreak $GEN\_GREATER\_THAN\_EQUALS$, $GEN\_EQUALS$,\linebreak $GEN\_NOT\_EQUALS$), one operand is $E$ and the type $T$ of the other operand is one of built-in types, then $T$ is also the inferred type of $S$.

\todo[inline]{Pěkné, neškodilo by proložit příklady, tj. dotaz, strom, co z něho odvodíme. -- To urobim pocas implementacie pre nejaky vzorovy dotaz.}

\section{Step 4: Key Discovery}
In this step, the algorithm discovers keys of elements, incorporating the approach from paper \cite{Necasky:2009:DXK:1529282.1529414}, described in Chapter \ref{Keys}, and extending it. Firstly, the syntax tree is searched for forms of FLWOR expressions to infer the keys from. Then, as described later, certain costructs are used to support or degrade the evidence of inferred statements in a final summarization.

\subsection{Join Patterns}

\begin{lstlisting}[mathescape, float, caption=Other form of the for join pattern., frame=single, label=listing_other_for_join_pattern]
for $\$e_1$ in $P_1$
for $\$e_2$ in
    $P_2[L_2 = \$e_1/L_1]$
return $C_R$
\end{lstlisting}

\begin{lstlisting}[mathescape, float, caption=Other form of the let join pattern., frame=single, label=listing_other_let_join_pattern]
for $\$e_1$ in $P_1$
let $\$e_2$ :=
    $P_2[L_2 = \$e_1/L_1]$
return $C_R$
\end{lstlisting}

\begin{lstlisting}[mathescape, float, caption=Join pattern 3., frame=single, label=listing_join_pattern_3]
for $\$e_1$ in $P_1$
for $\$e_2$ in $P_2$
where $\$e_2/L_2 = \$e_1/L_1$
return $C_R$
\end{lstlisting}

The two join patterns from the original approach are shown in Listings \ref{listing_for_join_pattern} and \ref{listing_let_join_pattern}. Additional join patterns are introduced in Listings \ref{listing_other_for_join_pattern}, \ref{listing_other_let_join_pattern} and \ref{listing_join_pattern_3}. In all join patterns $P_1$, $P_2$, $L_1$, $L_2$ are XQuery paths without predicates, using only child and descendant axes. Actually, the join patterns from Listings \ref{listing_other_for_join_pattern} and \ref{listing_other_let_join_pattern} are covered by the for and let join pattern in the original approach, but we introduce them explicitly because their structure in the syntax tree is different.

Since, in this step, we already know the types of all expressions in the syntax tree, the requirement that $P_1$, $P_2$, $L_1$, $L_2$ are paths of the described form can be replaced by a more general requirement that $P_1$, $P_2$, $L_1$, $L_2$ are expressions of $PathType$ without predicates, using only child and descendant axes.

As described in the original method and summarized in Chapter \ref{Keys} we recognize two cases (O1) and (O2) of inferrence of keys from occurrences of the join patterns, and rules to classify each occurrence into one of these cases. For the join pattern 3, we introduce a new rule, considering the join pattern 3 of case (O1), assigned with weight of 0.5. \todo{Popisat dovod nizsej vahy (nie je take jasne, ze je to par key-foreign key), pripadne zmenit vahu.}

\begin{algorithm}
\caption{Processing of FLWOR expressions}
\label{ALG_processing_of_flwor_expressions}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $flworNode$: A node representing a FLWOR expression. \\
    $forVars$: An array of couples of for variables and their for clause nodes.
}

\ENSURE Updated variable $forVars$.

\STATE $bindingNodes = bindingNode \in flworNode.getChild(TupleStreamNode).$ $getChildren()$

\STATE $whereClause = flworNode.getChild(WhereClauseNode)$
\STATE $checkJoinPattern3 = false$
\STATE $whereExpr = null$
\IF{$whereClause != null$}
    \STATE $whereExpr = whereClause.getChild(ExprNode)$
    \IF{$is(whereExpr, OperatorNode)$ AND $whereExpr.operator == GEN\_EQUALS$}
        \STATE $checkJoinPattern3 = true$
    \ENDIF
\ENDIF

\FORALL{$bindingNode \in bindingNodes$}
    \STATE $bindingExpr = bindingNode.getChild(BindingSequenceNode).$ $getChild(ExprNode)$
    \IF{$getType(BindingExpr) == PathType$ using only child and descendant axes, ending with exactly one predicate $P$}
        \FORALL{$(var, node) \in forVars$}
            \STATE $forVars = determinateJoinPatterns(bindingNode, P, node, var,$ $forVars,$ $checkJoinPattern3,$ $whereExpr)$
        \ENDFOR
    \ELSIF{$getType(BindingExpr) == PathType$ without predicates using only child and descendant axes}
        \IF{$is(bindingNode, ForClauseNode$}
            \STATE add $(bindingNode.varName, bindingNode)$ to forVars
        \ENDIF
    \ENDIF
\ENDFOR

\RETURN $forVars$
\end{algorithmic}
\end{algorithm}

\todo[inline]{Alg 6.12 FLWOR expressions - pre podmienky na riadkoch 13 a 17 definovat nejake funkcie}

\begin{algorithm}
\caption{Function determinateJoinPatterns}
\label{ALG_func_determinateJoinPatterns}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $curBindingNode$: A variable binding node in the current FLWOR node. \\
    $P$: A predicate from the binding expression. \\
    $forBindingNode$: A for binding node from an ancestor FLWOR node. \\
    $forVar$: A variable from the ancestor for binding node. \\
    $forVars$: An array of couples of for variables and their for clause nodes. \\
    $checkJoinPattern3$: A flag determining whether to analyze the join pattern as possible join pattern 3. \\
    $whereExpr$: An expression from a where clause of the current FLWOR node.
}

\ENSURE Updated variable $forVars$.

\IF{$P$ is of form $curBindingNode.varName/L_1 = var/L_2$}
    \IF{$is(curBindingNode, ForClauseNode)$}
        \STATE memorize $(forBindingNode, curBindingNode)$ as an occurrence of the for join pattern
        \STATE remove $(forVar, forBindingNode)$ from $forVars$
    \ELSIF{$is(curBindingNode, LetClauseNode)$}
        \STATE memorize $(forBindingNode, curBindingNode)$ as an occurrence of the for let pattern                
        \STATE remove $(forVar, forBindingNode)$ from $forVars$
    \ENDIF
\ELSIF{$checkJoinPattern3$ AND $is(curBindingNode, ForClauseNode)$}
    \IF{$whereExpr$ is of form $bindingNode.varName/L_1 = var/L_2$}
        \STATE memorize $(forBindingNode, curBindingNode)$ as an occurrence of the join pattern 3
        \STATE remove $(forVar, forBindingNode)$ from $forVars$
    \ENDIF
\ENDIF


\RETURN $forVars$
\end{algorithmic}
\end{algorithm}

\todo[inline]{Processing function pre join pattern 3.}

To find the occurrences of the join patterns, the algorithm recursively, in pre-order, searches the syntax tree and every node representing a FLWOR expression is processed. The FLWOR processing is shown in Algorithm \ref{ALG_processing_of_flwor_expressions}. Its input is an array of couples containing names of variables which has been bound in for clauses in FLWOR expressions represented by ancestor nodes, and references to those respective for clause nodes. The processing iterates through subnodes of a current node and the iteration consists of two logical parts.

In the first one, a subnode is checked if it is a for or let clause that forms a join pattern occurrence with one of clauses from the input array. If it does, the occurrence is noted. The responsible code is partially moved to function $determineJoinPatterns()$ in Algorithm \ref{ALG_func_determinateJoinPatterns}. If the subnode does not form an occurrence, and if it is a for clause binding a new variable satisfying the conditions to be the first for clause of a join pattern, it is added to the array along with the variable name. It can be then processed in the following clauses of the currect FLWOR node or in its descendant FLWOR nodes, later in the recursion.

\subsection{Analysis of the Join Pattern Occurrences}
For each found join pattern occurrence, the algorithm displayed in Algorithm \ref{ALG_classification_of_join_pattern_occurrences} decides whether it is (O1) or (O2) case, using the rules from the original method and the rule for the join pattern 3 considering it of case (O1) and assigning it with weight of 0.5.

\begin{algorithm}
\caption{Classification of join pattern occurrences}
\label{ALG_classification_of_join_pattern_occurrences}
\begin{algorithmic}[1]
\REQUIRE $\mathcal{O}$: A set of all found join pattern occurrences.

\ENSURE $\mathcal{O'}$: A set of the classified join pattern occurrences from $\mathcal{O}$ assigned with their respective weights.

\FORALL{$jpOccurrence \in \mathcal{O}$}
    \IF{$jpOccurrence$ is the for join pattern}
        \STATE mark $jpOccurrence$ as case (O1), weight 1
    \ELSIF{$jpOccurrence$ is the join pattern 3}
        \STATE mark $jpOccurrence$ as case (O1), weight 0.5
    \ELSE
        \STATE TODO (R2,R3,R4,R5)
    \ENDIF
    \STATE update $jpOccurrence$ in $\mathcal{O}$
\ENDFOR

\RETURN $\mathcal{O}$
\end{algorithmic}
\end{algorithm}

\subsection{Rejection of Uniqueness}
While the previous steps of the key discovery produce positive statements about the keys, in this step, the algorithm searches for evidence on non-uniqueness of elements and attributes. The aim of this step is to eliminate or decrease the number of falsely inferred keys.
\todo[inline]{Napisat niekam, ze odvodzovanie kludov predpoklada, ze kazdy element/element join je robeny cez key-foreign key pair.}
When the algorithm discovers that a certain element is probably not unique, it assigns the element with a negative weight that will decrease the sum of its weights in the summarizing step.

The first group of XQuery constructs utilized by this step is a group of $distinct-values$ function and aggregation functions $min$, $max$, $sum$ as discussed in Section \ref{Negative_uniqueness} and shown in Algorithm \ref{ALG_rejection_of_uniqueness_aggregation_functions}. The algorithm searches for calls of the mentioned functions with a $PathType$ on their input. Elements and attributes selected by those $PathTypes$ are then considered to be not unique, and consequently, they cannot be keys.

Contrary the key discovery, $PathTypes$ utilized in this step may contain predicates in their lasts steps. Predicates in a path's last step restrict its result, and therefore, if a set of elements or attributes selected by a path with predicates is not unique, neither is a set of elements or attributes selected by the same path stripped of the predicates.

\begin{algorithm}
\caption{Rejection of uniqueness - aggregation functions}
\label{ALG_rejection_of_uniqueness_aggregation_functions}
\begin{algorithmic}[1]
\REQUIRE $node$: A node of the syntax tree.

\IF{$is(node, FunctionCallNode)$}
    \IF{$node.fncName$ is one of $distinct-values$, $min$, $max$, $sum$}
        \STATE $argument = node.getChild(0)$
        \IF{$getType(argument) == PathType$ using only child and descendant axes, without predicates except the last step}
            \STATE memorize $argument$ as the negative key statement, weight 1
        \ENDIF
    \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

Besides the aggregation functions, a certain form of FLWOR expressions is utilized in this step. They are FLWORs that iterate through a sequence of nodes selected by a path expressions using only child and descendant axes, and either that path expressions end with a predicate comparing a value of a subnode with some other value (lieral constant, reference of a variable which is constant in this expressions, etc), or, the comparison is located in a where clause of a respective FLWOR.

As discussed in Section \ref{Negative_uniqueness}, when a for clause is used to iterate through a set of items, it is expected that the count of the items may be more than one. And, together with that, the set is restricted to contain only items which satisfy a condition that a value of one of their subnodes (or descendant nodes) equals a certain value. That implies that the value in those nodes is not unique, and, alike the utilization of the aggregation functions, non-unique nodes cannot be keys.

\begin{algorithm}
\caption{Rejection of uniqueness - comparison with a constant}
\label{ALG_rejection_of_uniqueness_comparison_with_a_constant}
\begin{algorithmic}[1]
\REQUIRE $node$: A node of the syntax tree.

\IF{$is(node, FLWORExprNode)$}
	\STATE $forVars =$ an empty array

    \FORALL{$bindingNode \in node.getChild(TupleStreamNode).getChildren()$}
        \IF{$is(bindingNode, ForClauseNode)$}
            \STATE $expr = bindingNode.getChild(BindingSequenceNode).$ $getChild(ExprNode)$
            \IF{$getType(expr) == PathType$ using only child and descendant axes}
                \STATE add $bindingNode.varName$ to $forVars$
            \ENDIF
        \ENDIF
    \ENDFOR
    
    \STATE $whereClause = node.getChild(WhereClauseNode)$
	\IF{$whereClause != null$}
    	\STATE $processWhere(forVars, whereClause.getChild(ExprNode))$
	\ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Rejection of uniqueness - function processWhere}
\label{ALG_rejection_of_uniqueness_function_process_where}
\begin{algorithmic}[1]
\REQUIRE{\ \\
	$forVars$: Names of variables to look for in the where expression. \\
	$exprNode$: The where expression node.
}

\IF{$is(exprNode, OperatorNode$)}
    \IF{$exprNode.operator == GEN\_EQUALS$}
        \FORALL{$var \in forVars$}
            \IF{$exprNode$ is of a form $var/L = C$ where $L$ is a path without predicates, except the last step, using only child and descendant axes, and C is a literal constant}
                \STATE memorize $var/L$ as the negative key statement, weight 0.9
            \ENDIF
        \ENDFOR
    \ELSIF{$exprNode.operator == AND$}
        \STATE $processWhere(forVars, exprNode.leftSide)$
        \STATE $processWhere(forVars, exprNode.rightSide)$
    \ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function usesOnlyChildAndDescendantAxes}
\label{ALG_function_uses_only_child_and_descendant_axes}
\begin{algorithmic}[1]
\REQUIRE $pathType$: A $PathType$ instance.
\ENSURE A boolean result.

\todo[inline]{Dalsie pomocne funkcie a zaradit ich do nejakej kapitoly o pom. funkciach.}
\FORALL{$stepNode \in pathType.stepNodes$}
	\IF{$stepNode.isAxisStep()$}
		\STATE $axisKind = stepNode.getAxisNode().getAxisKind()$
		\IF{$axisKind$ $!=$ $CHILD$ $AND$ $axisKind$ $!=$ $DESCENDANT$}
			\RETURN false
		\ENDIF
	\ENDIF
\ENDFOR

\STATE $detailNode = stepNode.getChild(ExprNode)$
\IF{$detailNode != null$}
	\IF{$is(detailNode, VarRefNode)$}
		\IF{$usesOnlyChildAndDescendantAxes($ $pathType.forBoundSubsteps[stepNode]) ==$ false}
			\RETURN false
		\ENDIF
	\ENDIF
\ENDIF

\RETURN true
\end{algorithmic}
\end{algorithm}
