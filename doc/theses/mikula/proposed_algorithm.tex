\chapter{Proposed Algorithm}
\todo[inline]{Nejaky uvod}
\todo[inline]{Lexikalna a syntakticka analyza z diplomky J. Schejbala}
\todo[inline]{Staticka analyza typov vyrazov}

\section{Step 1: Construction of a Syntax Tree}
The first step of the algorithm involves lexical and syntactic analyses and produces a syntax tree. The analyses are taken from Ji\v r\'{i} Schejbal's master thesis \todo{ref}. Since they are much more an issue of implementation than an issue of principle and they are not directly related to the inference, we will not describe them in this thesis.

The mentioned thesis provides us with a helpful processing of XQuery queries, however, it needs to be slightly modified to suit our case. The processing writes its result to a file in an XML representation. Instead of that, we need to keep the result in memory and pass it to consecutive steps of our algorithm. Though, this requirement concerns modifications of implementation while the core of the processing remains untouched. Therefore, we also do not describe these modifications.

Since we only modified the implementation of the output representation, the design of the syntax tree remains consequent to the entire design of the processing. Each node represents a logical component of a query. Inner nodes stand for XQuery constructs that are composed of other constructs and can be further divided. Examples of such constructs are FLWORs, if-than-else and function calls. Leaf nodes represents elements of XQuery language that can be devided no more. Typical representants are literal constants. \todo{zistit, ci konstanty nahodou nie su jedine}

\todo[inline]{priklad stromu}
\todo[inline]{niekam popisat celu moznu strukturu stromu - najskor do appendixu}

\section{Step 2: Static Analysis of Expression Types}
In the second step, we try to statically (without evaluation of the queries) determine types of expressions in the syntax tree. This process can be divided into three substeps.

\subsection{Determination of Function Return Types}
Determination of Return Types of Functions is needed because function calls can appear in expressions. However a return type of a function can be determined when the analysis of expressions encounters a call of the function, it involves multiple number of transitions of the syntax tree in a search for a definition of a particular function.

Instead, the syntax tree can be searched just once, before the analysis of expressions, and return types of all functions found will be stored within an associative array. On request, this array will retrieve the return type of a specified function.

A simple algorithm is presented in \ref{ALG_determination_of_function_return_types} \todo{uvadzat aj taketo jednoduche funkcie?}. It uses \texttt{getFunctionDeclarationNodes()} function, which is not presented due to its simplicity. It returns a list of all function declaration nodes in the syntax three. Actually, it does not have to search the whole syntax tree as the function declaration nodes can be present only in query prolog. 

For simplicity, we will focus on locally defined functions. We will not determine types of functions defined in other modules \todo{je to ok?}. Return types of built-in functions are fixed, and thus, there is no need to analyze them.

\begin{algorithm}
\caption{Determination of Function Return Types}
\label{ALG_determination_of_function_return_types}
\begin{algorithmic}[1]
\ENSURE An associative array of function names with their types.

\STATE $functionTypes$ = empty associative array
\FORALL{$functionDeclarationNode \in getFunctionDeclarationNodes()$}
    \STATE $functionName = functionDeclarationNode.getFunctionName()$
    \STATE $functionTypes[functionName] = functionDeclarationNode.getReturnType()$
\ENDFOR
\RETURN $functionTypes$
\end{algorithmic}
\end{algorithm}

For the rest of the thesis, we assume function \texttt{getFunctionReturnType()} which takes a function name and returns the return type of the function if the function is either built-in or it is recorded in the associative array. Otherwise, \texttt{null} is returned.

\subsection{Determination of Global Variable Types}
A similar approaches as in the case of functions can be applied to determine types of global variables. Alike the functions, the global variables are defined in the prolog section. A type of a variable can be explicitly specified in the definition \todo{je to tak? priklad}. If it is not it may be often deducible from the binding expression.

\begin{algorithm}
\caption{Determination of an Expression Type}
\label{ALG_determination_of_an_expression_type}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $exprNode$: An expression node in the syntax tree. \\
    $contextVarTypes$: Types of local variables valid in current context.
}
\ENSURE The expression type.

\STATE $type = null$
\IF{$exprNode$ represents a literal value}
     \STATE $type =$ particular literal value type
\ELSIF{$exprNode$ represents a call of function $f$}
     \STATE $type = getFunctionReturnType(f)$
\ELSIF{$exprNode$ represents variable reference $var$}
     \STATE $type = getVariableType(contextVarTypes, var)$
\ELSIF{$exprNode$ represents path expression $path$}
     \STATE $type = TODO$
\ELSIF{$exprNode$ represents operator $op$}
      \STATE TODO
\ENDIF

\RETURN $type$
\end{algorithmic}
\end{algorithm}

The algorithm iterates through the variable declaration nodes from the prolog and if the variable is explicitly assigned with its type than the type is noted. Otherwise, an attempt of the type deduction the expression is be made. The deduction of type from the expression is presented in \ref{ALG_determination_of_an_expression_type}. On input, it takes an expression node and types of local variables that are valid in the expression. The presented algorithm is just shortened illustration since the complete version is too long to be presented in this text. Nevertheless, the principle is straightforward. Depending on the type of the expression, its type can be either determined directly or it depends on its subexpressions which types can be determined recursively. In the case of global variables, the argument $contextVarTypes$ is empty because there are no local variables valid in the prolog section.

The types of processed global variables are available trough function $getGlobalVariableType()$. If the function gets a variable that is not a global one, it returns $null$. Function $getVariableType()$ called in \ref{ALG_determination_of_an_expression_type} is defined in \ref{ALG_function_get_variable_type}. It checks if the specified variable is amongst the given local variables. If so, it returns its type, else it handles the variable as a global one and if such global variable does not exist the result is $null$.

\begin{algorithm}
\caption{Function getVariableType}
\label{ALG_function_get_variable_type}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $contextVarTypes$: Types of local variables valid in current context. \\
    $var$: A variable to determine the type of.
}
\ENSURE The type of variable $var$.

\IF{$contextVarTypes[var]$ is defined}
     \RETURN $contextVarTypes[var]$
\ELSE
     \RETURN $getGlobalVariableType(var)$
\ENDIF
\end{algorithmic}
\end{algorithm}

\subsection{Analysis of Expressions}
\todo[inline]{Je nutne analyzovat aj typy deklarovanych premennych, kedze tie sa mozu pouzivat vo vyrazoch.}


\section{Inference of Built-in Types}
Prejst kazdy vyraz a ak z neho vieme nieco odvodit, tak to urobime.

Odvodit nieco vieme ak:
Nejaky podvyraz je path expression (alebo ine urcenie uzlu alebo hodnot uzlov \todo{toto domysliet}
a zaroven cely vyraz
1) je function call a podvyraz je jeho parameter a typ tohoto parametra vieme odvodit z hlavicky funkcie
2) je aritmeticka operacia a podla typov operandov vieme urcit typ podvyrazu (tj napriklad sa uzly porovnavaju s konstantou 5) \todo{co vsetko?}
3) dalsie konstrukcie ako cast as, type constructor, ... \todo{potrebuje riesit? princip je uplne rovnaky}



\begin{algorithm}
\caption{Repair RW-XML tree}
\label{propAlgo}
\begin{algorithmic}[1]
\REQUIRE $queryTrees$: A list of input query trees
\ENSURE Uzly a ich typy nejakym sposobom

\STATE initializacia nodeTypes
\FORALL{$queryTree \in queryTrees$}
    \STATE $partialNodeTypes = processQueryTree(queryTree)$
    \STATE $nodeTypes = mergeNodeTypes(nodeTypes, partialNodeTypes)$
\ENDFOR
\RETURN $nodeTypes$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Process arithmetic comparison}
\label{algorithm_process_arithmetic comparison}
\begin{algorithmic}[1]
\REQUIRE $expr$: An expression which is an arithmetic comparison
\ENSURE Uzly a ich typy nejakym sposobom

\STATE initializacia nodeTypes
\RETURN $nodeTypes$


\WHILE{$resultRXT \not \models_w \mathcal{FD}$}
    \STATE $S = \emptyset$ \COMMENT Set of repair groups
    \FORALL{$(F: S \rightarrow p) \in \mathcal{FD}$ s.t. $RXT \not \models_w F$}
    	\FORALL{$t_1, t_2$ tuples of $RXT$ s.t. $t_1, t_2$ do not weakly satisfy $F$}
		    \STATE $S = S \cup computeRepairGroup(F, t_1, t_2, RXT, S)$
	    \ENDFOR
    \ENDFOR

    \STATE $R = getRepair(S, RXT)$
    \STATE $resultRXT = applyRepair(R, resultRXT)$
\ENDWHILE
\end{algorithmic}
\end{algorithm}