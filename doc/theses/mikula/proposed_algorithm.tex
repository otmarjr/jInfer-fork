\chapter{Proposed Algorithm}
\todo[inline]{Nejaky uvod a zkratke hrnutie}
\todo[inline]{Lexikalna a syntakticka analyza z diplomky J. Schejbala}
\todo[inline]{Staticka analyza typov vyrazov}
\todo[inline]{Predpoklad korektnosti dotazov}

\section{Step 1: Construction of a Syntax Tree}
The first step of the algorithm involves lexical and syntax analyses known from the construction of compilers and produces a so-called syntax tree. The analyses are taken from Ji\v r\'{i} Schejbal's master thesis \todo{ref}. Since they are not directly related to the inference, and thus, they are not directly related to the topic of this thesis, we will not describe them. Nevertheless, they provides us with a helpful processing of XQuery queries and we can focus on the inference.

The syntactic analysis needs to be slightly modified to suit our case. It writes its result into a file in an XML representation. Instead, we need to keep the result in memory and pass it to consecutive steps of our algorithm. Though this requirement concerns modifications of implementation, the core of the processing remains untouched. Therefore, we also do not describe these modifications.

\subsection{Definition of the Syntax Tree}
Firstly, we formally define the syntax tree.

\begin{define}[Syntax tree]
\label{DEF_syntax_tree}
Syntax tree of XQuery query $Q$ is tuple $T = (V, E, c, \mathcal{P}, o)$ where $V \subset \mathbb{N}$ is a set of nodes, each node representing a particular XQuery construct in query $Q$, $E$ is a set of pairs $(v, w)$ where $v,w \in V$ and for every $a, b \in V, a \neq b: (a, b) \in E$ if and only if a construct represented by $b$ is a direct component of a construct represented by $a$ ($b$ is a child of $a$) in query $Q$, $c: V \rightarrow C$ is function assigning each node with its class from set $C$ of all XQuery language constructs listed in Figures \ref{FIG_syntax_tree_node_types_part_1}, \ref{FIG_syntax_tree_node_types_part_2}, \ref{FIG_syntax_tree_node_types_part_3}, \ref{FIG_syntax_tree_node_types_part_4}, \ref{FIG_syntax_tree_node_types_part_5}, \ref{FIG_syntax_tree_node_types_part_6}, \ref{FIG_syntax_tree_node_types_part_7}, \ref{FIG_syntax_tree_node_types_part_8}, \ref{FIG_syntax_tree_node_types_part_9}, $\mathcal{P}$ is a set of functions specifying additional properties of the nodes and distinguishing the nodes of the same classes, and $o : V \rightarrow \mathcal{O}$ is a function specifying an order of children of the nodes where $\mathcal{O} = \{o_v : E_v \rightarrow \mathbb{N} | v \in V, E_v = \{(v, w) | w \in V, (v,w) \in E\}\}$ is set of functions specifying the children order for each node. For every $v \in V, o(v) = o_v$ so that $o_v(v,w)$ is a sequential number of a construct represented by $w$ amongst constructs represented by children of $v$ in query $Q$. 
\end{define}

Regarding the additional properties, two constructs in $Q$ represented by two nodes of the same class from $C$ may differ in certain ways, and therefore, it is needed to distinguish them. For instance, two different literal values in $Q$ are represented by nodes $l_1, l_2 \in V$ and $c(l_1) = c(l_2) = LiteralNode$ but each has a different value and type. Therefore $\mathcal{P}$ contains functions \\
$type_{LiteralNode}: V_{LiteralNode} \rightarrow Types_{literal}$ \\
$value_{LiteralNode}: V_{LiteralNode} \rightarrow Values_{literal}$ \\
where $V_{LiteralNode}$ is set $\{v | v \in V, c(v) = LiteralNode\}$, $Types_{literal}$ is set of all types of literal values $\{DECIMAL, INTEGER, DOUBLE, STRING\}$, and $Values_{literal}$ is a set of all literal values (all valid XQuery decimal numbers, integers, double numbers and strings).

Set $\mathcal{P}$ contains other similar functions but due to their large count, we do not define them formally.
\todo[inline]{Moze takto ostat, alebo definovat aspon tie co pouzivame? Alebo ich aspon vypisat?}

\subsection{Syntactic Abbreviations}
Since we need to use the syntax tree in pseudo-algorithms, we define the following abbreviations to make its usage more simple.

For every $v \in V$, abbreviation
\begin{itemize}
\item $v.p$ stands for $p_{c(v)}(v)$ if $p_{c(v)} \in \mathcal{P}$.
\item $v.getChildren()$ stands for $\{w | w \in V, (v,w) \in E\}$ which is a set of all children of $v$.
\item $v.getChild(i)$, $i \in \mathbb{N} \cup \{0\}$, stands for $w \in V$ so that $o(v)(v,w) = i + 1$.
\item $v.getChild(class), class \in C$, stands for $w \in V$ so that $(v,w) \in E$ and $c(w) = class$, if $\Bigl | \{u | u \in V, (v,u) \in E, c(u) = class\}\Bigr | = 1$.
\end{itemize}

\todo[inline]{Je nutne presnejsie popisat kedy a preco tieto skratky maju zmysel? V pseudo-kodoch budu samozrejme pouzivane len v pripadoch, ked su dobre definovane a maju zmysel.}

\subsection{Closer Look at the Nodes of the Syntax Tree}
\todo[inline]{Dat figures do appendixu?}
The node classes of the syntax are organized in an is-a hierarchical structure, commonly used in the object oriented programming languages, where an object can be of several types. This hierarchy is shown in Figures \ref{FIG_syntax_tree_node_types_part_1}, \ref{FIG_syntax_tree_node_types_part_2}, \ref{FIG_syntax_tree_node_types_part_3}, \ref{FIG_syntax_tree_node_types_part_4}, \ref{FIG_syntax_tree_node_types_part_5}, \ref{FIG_syntax_tree_node_types_part_6}, \ref{FIG_syntax_tree_node_types_part_7}, \ref{FIG_syntax_tree_node_types_part_8}, \ref{FIG_syntax_tree_node_types_part_9}. The classes with emphasised names represent a common class of a group of subclasses, and these classes cannot be directly used in the syntax tree (abstract classes). The remaining nodes represent particular constructs of the XQuery language and nodes of these classes can be used in the syntax tree. 

For example, an instance of the syntax tree cannot directly contain nodes of $Node$ and $ExprNode$ classes (for every $v \in V, c(v) \neq Node, c(v) \neq ExprNode$), but it can contain nodes of $AttributeNode$ and $LiteralNode$ classes. Regarding the multiplicity of types, a node of $LiteralNode$ class is also considered to be of two indirect types: $ExprNode$ and $Node$.

\todo[inline]{Asi bude potrebne nakreslit pre kazdy node, co presne obsahuje. Alebo staci pre tie, ktore budeme my pouzivat?}

The node classes can be classified into three groups: inner node classes, leaf node classes and node classes that can be both inner and leaf. Inner node classes (marked $I$) stand for XQuery constructs that are composed of other constructs and can be further divided. An example of such class is $FLWORExprNode$ which is composed of $TupleStreamNode$, $WhereClauseNode$, $OrderByClauseNode$ and $ReturnClauseNode$ classes. Leaf node classes (marked $L$) represent elements of XQuery language that cannot be further divided. For example, $LiteralNode$. Node $FunctionCallNode$ is an example of the third group (marked $IL$). Function call of a function without arguments is represented by a leaf node while function call with arguments is represented by an inner node and its subnodes are nodes representing those arguments.

\begin{figure}
\caption{Syntax tree node types part 1.}
\label{FIG_syntax_tree_node_types_part_1}
\begin{description}
\item \textbf{Node}
\begin{description}
\item AttributeNode (I)
\item AttrListNode (IL)
\item AxisNode (I)
\item CaseClauseNode (I)
\item CaseClausesNode (I)
\item CDataSectionNode (L)
\item ContentNode (IL)
\item DefaultCaseNode (I)
\item EntityRefNode (L)
\item \textbf{ExprHolderNode}
\item \textbf{ExprNode}
\item FunctionBodyNode (IL)
\item CharRefNode (L)
\item InClausesNode (I)
\item \textbf{ItemTypeNode}
\item LocationHintNode (L)
\end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 2.}
\label{FIG_syntax_tree_node_types_part_2}
\begin{description}
\item \textbf{Node}
\begin{description}
\item LocationHintsNode (IL)
\item \textbf{ModuleChildNode}
\item ModuleNode (I)
\item NameNode (IL)
\item OrderByClauseNode (I)
\item OrderSpecNode (I)
\item ParamListNode (I)
\item ParamNode (I)
\item PITargetNode (IL)
\item PragmaListNode (I)
\item PragmaNode (L)
\item PredicateListNode (I)
\item \textbf{PrologChildNode}
\item StepExprNode (I)
\item StringNode (L)
\item TupleStreamNode (I)
\item TypeNode (L)
\item \textbf{VariableBindingNode}
\item VarValueNode (IL)
\end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 3.}
\label{FIG_syntax_tree_node_types_part_3}
\begin{description}
\item \textbf{ExprHolderNode}
  \begin{description}
  \item BindingSequenceNode (I)
  \item DefaultValueNode (I)
  \item ElseExpressionNode (I)
  \item OperandExpressionNode (I)
  \item ReturnClauseNode (I)
  \item TestExpressionNode (I)
  \item ThenExpressionNode (I)
  \item WhereClauseNode (I)
  \end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 4.}
\label{FIG_syntax_tree_node_types_part_4}
\begin{description}
\item \textbf{ExprNode}
  \begin{description}
  \item CommaOperatorNode (I)
  \item ConstructorNode (I)
  \item ContextItemExprNode (L)
  \item EmptySequenceNode (L)
  \item ExtensionExprNode (I)
  \item FLWORExprNode (I)
  \item FunctionCallNode (IL)
  \item IfExprNode (I)
  \item LiteralNode (L)
  \item OperatorNode (I)
  \item OrderedExprNode (I)
  \item PathExprNode (I)
  \item QuantifiedExprNode (I)
  \item TypeswitchExprNode (I)
  \item UnorderedExprNode (I)
  \item ValidateExprNode (I)
  \item VarRefNode (L)
  \end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 5.}
\label{FIG_syntax_tree_node_types_part_5}
\begin{description}
\item \textbf{ItemTypeNode}
  \begin{description}
  \item AnyItemNode (L)
  \item AtomicTypeNode (L)
  \item KindTestNode (IL)
  \item NameTestNode (L)
  \end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 6.}
\label{FIG_syntax_tree_node_types_part_6}
\begin{description}
\item \textbf{ModuleChildNode}
  \begin{description}
  \item ModuleDeclNode (L)
  \item PrologNode (IL)
  \item QueryBodyNode (I)
  \end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 7.}
\label{FIG_syntax_tree_node_types_part_7}
\begin{description}
\item \textbf{PrologChildNode}
  \begin{description}
  \item BaseURIDeclNode (L)
  \item BoundarySpaceDeclNode (L)
  \item ConstructionDeclNode (L)
  \item CopyNamespacesDeclNode (L)
  \item DefaultCollationDeclNode (L)
  \item DefaultNamespaceDeclNode (L)
  \item EmptyOrderDeclNode (L)
  \item FunctionDeclNode (I)
  \item \textbf{ImportNode}
    \begin{description}
    \item ModuleImportNode (I)
    \item SchemaImportNode (I)
    \end{description}
  \item NamespaceDeclNode (L)
  \item OptionDeclNode (L)
  \item OrderingModeDeclNode (L)
  \item VarDeclNode (I)
  \end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 8.}
\label{FIG_syntax_tree_node_types_part_8}
\begin{description}
\item StepExprNode (I)
  \begin{description}
  \item SelfOrDescendantStepNode (L)
  \end{description}
\end{description}
\end{figure}

\begin{figure}
\caption{Syntax tree node types part 9.}
\label{FIG_syntax_tree_node_types_part_9}
\begin{description}
\item \textbf{VariableBindingNode}
  \begin{description}
  \item ForClauseNode (I)
  \item InClauseNode (I)
  \item LetClauseNode (I)
  \end{description}
\end{description}
\end{figure}

Some pseudo code algorithms in the following sections need to determine a class of a node. The node's direct class can be determined by function $c$ from the definition of the syntax tree \ref{DEF_syntax_tree}, and hence, we also can determine its indirect classes. For the purpose of pseudo code, we define the following function. For every $v \in V$ and every $class \in C$, function $is(v, class)$ returns boolean value $true$ if $c(v) = class$ or $c(v)$ is a (direct or indirect) subclass of $class$, according to the described principle. Otherwise, it returns $false$.

For instance, assuming $v \in V, c(v) = LiteralNode$, calls $is(v, LiteralNode)$, $is(v, ExprNode)$ return $true$, while call $is(v, ContentNode)$ returns $false$.

\subsection{Characteristics of the Syntax Tree}
An important characteristic of the syntax tree is related to a definition of local variables and their scope in the XQuery language. The representation of a definition of a local variable in the syntax tree is a node of $VariableBinding$ class. Nodes of that class contain have only two children; a node representing the type of the variable and a node representing the binding expression (expression defining the value of the variable, and thus, it cannot use the variable). Hence, the entire subtree doesn't contain any expressions that use the variable. Therefore the scope of the new variable is not the subtree of the $VariableBinding$ class node. It depends on the type of XQuery construct that the variable binding is a (indirect) component of.

For example, a node of $FLWORExpr$ class contains four subnodes of $TupleStream$, $WhereClause$, $OrderByClause$ and $ReturnClause$ classes. The $TupleStream$ class node contains a list of node of $variableBinding$ class which define variables valid in all other three subnodes of the FLWOR node.

\todo[inline]{Nejak sa z tohoto vytratilo to, preco to je pre nas dolezita charakteristika}

\todo[inline]{priklad stromu}

\section{Step 2: Static Analysis of Expression Types}
In the second step, we statically (i.e. without evaluation of the queries) determine types of expressions in the syntax tree. Information on the types of expressions can be used by consecutive steps of the algorithm. The consecutive steps will not use the determined types of all expressions, however this step may be useful in a future extending.

\todo[inline]{Tady z těch try a probably je jasně vidět, že netušíte co vlastně přesně algoritmus bude dělat. Nejdříve si to rozmyslete, pak pište text. Rozhodně by se takové výrazy neměly v DP dobjevovat, působít o velmi nedůvěryhodně. Měl by to být strohý popis toho, co bylo uděláno.}

We want to capture the following types.

\begin{itemize}
\item XML Schema built-in atomic types \todo{link do appendixu}.
\item Types $ElementType$, $AttributeType$, $NodeType$, $TextNodeType$, $CommentType$, $ProcessingInstructionType$, $DocumentType$ representing an element, attribute, node, text node, comment, processing instruction, document node.
\item Type representing a node selected by a certain path expression. The path expression is included in this type. Let this type be identified as $PathType$.
\end{itemize}

To capture sequences, we assign each type with its cardinality as proposed in \todo{ref na Schajbalovu diplomku}. Every type can be perceived as a sequence. A type representing one value or one item can be perceived as a sequence of exactly one item. The cardinality expresses one of the following five sequence types.

\begin{itemize}
\item An empty sequence.
\item A sequence of exactly one item.
\item A sequence containing zero or one item (modifier $?$).
\item A sequence containing zero or more items (modifier $*$).
\item A sequence containing one or more items (modifier $+$).
\end{itemize}

$PathType$ has always cardinality of zero-or-more, because the result of a path expression is a general sequence and since we do not evaluate the queries we cannot determine its actual cardinality.

If we cannot determine the type of an expression, we express that using $null$. An example of such case is path expression $/rootElement/(elementA * 2)$. \todo{Nejak dopisat}

The analysis of expression types can be divided into three substeps. Determination of return types of functions, determination of types of global variables, and finally determination of types of expressions.

\todo[inline]{Este by sa dala urobit analyza volania funkcii, do ktorych su predavane nejake elementy/atributy o ktorych vieme ich path expression. Vysledkom tejto funkcie by totiz zas mohli byt elementy/atributy o ktorych vieme (pozmenenu) path expression a nie len nezname elementy/atributy.
A: Přesně tak. A jak říkám - není třeba vše co navrhnete implementovat.}

\subsection{Determination of Function Return Types}
Determination of return types of functions is needed because function calls can appear in expressions. A return type of a function can be determined at the moment the analysis of expressions encounters a call of the function, however, it involves multiple transitions of the syntax tree in a search for a definition of a particular function.

Instead, the syntax tree can be searched just once, before the analysis of expressions, and return types of all functions found are stored.

\begin{algorithm}
\caption{Retrieval of Function Declaration Nodes $getFunctionDeclarationNodes(syntaxTree)$}
\label{ALG_retrieval_of_function_declaration_nodes}
\begin{algorithmic}[1]
\REQUIRE $syntaxTree$: A reference to the root node of a syntax tree.
\ENSURE A list of syntax tree nodes representing function declarations.

\STATE $prologNode = null$
\FORALL{$moduleChildNode \in syntaxTree.getChildren()$}
    \IF{$is(moduleChildNode, PrologNode)$}
        \STATE $prologNode = moduleChildNode$
    \ENDIF
\ENDFOR

\STATE $functionDeclarationNodes =$ an empty list
\IF{$prologNode \neq null$}
    \FORALL{$prologChildNode \in prologNode.getChildren()$}
        \IF{$is(prologChildNode, FunctionDeclNode)$}
            \STATE add $prologChildNode$ to $functionDeclarationNodes$
        \ENDIF
    \ENDFOR
\ENDIF

\RETURN $functionDeclarationNodes$
\end{algorithmic}
\end{algorithm}

A simple algorithm is presented in Algorithm \ref{ALG_processing_of_functions} \todo{Q: uvadzat aj taketo jednoduche funkcie? A: Obecně by mělo být popsáno vše. Ale pokud se nějaká jednoduchá věc např. opakuje, tak stačí napsat, že je algoritmus podobný jako v předchozím případě nebo tak něco.}. It uses \texttt{getFunctionDeclarationNodes()} function, defined in Algorithm \ref{ALG_retrieval_of_function_declaration_nodes}, which returns a list of all function declaration nodes in the syntax three. Actually, it does not have to search the whole syntax tree as the function declaration nodes can be present only in the query prolog section. 

Without loss of generality, we will focus on locally defined functions. We will not determine types of functions defined in other modules since the principle is similar but it is needed to look up the definitions in syntax trees of other queries. Return types of built-in functions are fixed and, thus, there is no need to analyse them.

\begin{algorithm}
\caption{Processing of Functions}
\label{ALG_processing_of_functions}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $getFunctionDeclarationNodes()$: Function defined in Algorithm \ref{ALG_retrieval_of_function_declaration_nodes}. \\
    $getTypeTN()$: Function defined in Algorithm \ref{ALG_extraction_of_a_type_from_typenode}. \\
    $syntaxTree$: A reference to the root node of a syntax tree.
}
\ENSURE An associative array of function names with their types and references to the their declaration nodes.

\STATE $functionArray$ = an empty associative array
\FORALL{$functionDeclarationNode \in getFunctionDeclarationNodes(syntaxTree)$}
    \STATE $functionName = functionDeclarationNode.funcName$
    \STATE $typeNode = functionDeclarationNode.getChild(TypeNode)$
    \STATE $functionArray[functionName] = (getTypeTN(typeNode), functionDeclarationNode)$
\ENDFOR
\RETURN $functionArray$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Extraction of a Type from TypeNode getTypeTN()}
\label{ALG_extraction_of_a_type_from_typenode}
\begin{algorithmic}[1]
\REQUIRE $typeNode$: Syntax tree node of TypeNode class.
\ENSURE Type extracted from $typeNode$.

\STATE $type = null$
\STATE $cardinality = typeNode.cardinality$
\STATE $itemTypeNode = typeNode.getChild(ItemTypeNode)$
\IF{$is(itemTypeNode, AtomicTypeNode)$}
    \STATE $type = itemTypeNode.typeName$
\ELSIF{$is(itemTypeNode, KindTestNode)$}
    \STATE $type = itemTypeNode.nodeKind$
\ENDIF

\RETURN $type$, $cardinality$
\end{algorithmic}
\end{algorithm}

\todo[inline]{ALG Extraction of a Type from TypeNode nie uplne sedi s definiciou typov. DP JS ma nieco navyse.}

For the rest of the thesis, we assume function $getFunctionReturnType()$ which takes a function name and returns the return type of the function if the function is either built-in or it is recorded in the associative array. Otherwise, \texttt{null} is returned.

Later phases of the algorithm may need to process the declarations of certain functions. Therefore, we also store references to the entire function declaration nodes, accessible using function $getFunctionDeclNode()$.

\subsection{Determination of Global Variable Types}
A similar approach as in the case of functions can be applied to determine types of global variables. Alike the functions, the global variables are defined in the prolog section. A type of a variable can be explicitly specified in its definition \todo{je to tak? priklad}. If it is not, it may often be deducible from the binding expression. Again, we do not analyse external variables for the same reason as in case of external functions.

\todo[inline]{ALG \ref{ALG_func_determineExpressionType}: Vymysliet a dopisat ako ziskavat typ z PathExprNode. Bude potrebne vyskusat implementaciu, ako sa chova.}

\begin{algorithm}
\caption{Function determineExpressionType()}
\label{ALG_func_determineExpressionType}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $getFunctionReturnType()$: Function returning a type of a function. \\
    $getVariableType()$: Function returning a type of a variable. \\
    $determineOperatorType()$: Function defined in \ref{ALG_func_determineOperatorType}. \\
    $getType()$: Function returning a type of already processed expression. \\
    $exprNode$: An expression node in the syntax tree. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}
\ENSURE The expression type.

\STATE $type = null$
\IF{$is(exprNode, LiteralNode)$}
     \STATE $type =$ XSD atomic type $exprNode.type$, exactly-once cardinality
\ELSIF{$is(exprNode, FunctionCallNode)$}
     \STATE $type = getFunctionReturnType(exprNode.fncName)$
\ELSIF{$is(exprNode, VarRefNode)$}
     \STATE $type = getVariableType(contextVarTypes, exprNode.varName)$
\ELSIF{$is(exprNode, PathExprNode)$}
     \IF{$exprNode$ selects an element set}
         \STATE $type = ElementType$, zero-or-more cardinality, $exprNode$ included
     \ELSIF{$exprNode$ selects an attribute set}
         \STATE $type = AttributeType$, zero-or-more cardinality, $exprNode$ included
     \ENDIF
\ELSIF{$is(exprNode, OperatorNode)$}
     \STATE $type = determineOperatorType(exprNode, contextVarTypes)$
\ELSIF{$is(exprNode, FLWORExprNode)$}
     \STATE $returnClauseNode = exprNode.getChild(ReturnClauseNode)$
     \STATE $type = getType(returnClauseNode)$
\ENDIF

\RETURN $type$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function determineOperatorType()}
\label{ALG_func_determineOperatorType}
\begin{algorithmic}[1]
\REQUIRE{\ \\ 
    $getType()$: Function returning a type of already processed expression. \\
    $isOperatorClassComparison()$: Function defined in \ref{ALG_func_isOperatorClassComparison}. \\
    $isOperatorClassAddition()$: Function defined in \ref{ALG_func_isOperatorClassAddition}. \\
    $isNumericType()$: Function defined in \ref{ALG_func_isNumericType}. \\
    $selectMoreGenericNumericType()$: Function that select a more generic numeric XSD type from two given types according to the type promotions rules (TODO-REF). \\
    $operatorNode$: An operator expression node in the syntax tree. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}
\ENSURE The operator expression type.

\STATE $type = null$
\STATE $operator = operatorNode.operator$
\IF{$isOperatorClassComparison(operator)$}
    \STATE $type = xs:boolean$, exactly-one cardinality
\ELSIF{$isOperatorClassAddition(operator)$}
    \STATE $leftOperandType = getType(exprNode.leftSide)$
    \STATE $rightOperandType = getType(exprNode.rightSide)$
    \IF{$isNumericType(leftOperandType)) AND isNumericType(rightOperandType)$}
        \STATE $type = selectMoreGeneralNumericType(leftOperandType, rightOperandType)$
    \ELSIF{$isNumericType(leftOperandType)$}
        \STATE $type = leftOperandType$
    \ELSIF{$isNumericType(rightOperandType)$}
        \STATE $type = rightOperandType$
    \ENDIF
\ENDIF

\RETURN $type$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function isOperatorClassComparison()}
\label{ALG_func_isOperatorClassComparison}
\begin{algorithmic}[1]
\REQUIRE $operator$: Representation of a XQuery operator.
\ENSURE $true$ if $operator$ is a comparison operator, $false$ otherwise.

\IF{$operator$ equals one of $GEN\_EQUALS$, $GEN\_GREATER\_THAN$, $GEN\_GREATER\_THAN\_EQUALS$, $GEN\_LESS\_THAN$, $GEN\_LESS_THAN\_EQUALS$, $GEN\_NOT\_EQUALS$, $VAL\_EQUALS$, $VAL\_GREATER\_THAN$, $VAL\_GREATER\_THAN\_EQUALS$, $VAL\_LESS\_THAN$, $VAL\_LESS\_THAN\_EQUALS$, $VAL\_NOT\_EQUALS$}
    \RETURN $true$
\ELSE
    \RETURN $false$
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function isOperatorClassAddition()}
\label{ALG_func_isOperatorClassAddition}
\begin{algorithmic}[1]
\REQUIRE $operator$: Representation of a XQuery operator.
\ENSURE $true$ if $operator$ is an addition operator, $false$ otherwise.

\IF{$operator$ equals one of $PLUS$, $MINUS$}
    \RETURN $true$
\ELSE
    \RETURN $false$
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function isNumericType()}
\label{ALG_func_isNumericType}
\begin{algorithmic}[1]
\REQUIRE $type$: Representation of a type.
\ENSURE $true$ if $type$ represents one of the XSD atomic built-in numeric types, $false$ otherwise.

\IF{$type$ represents one of $float$, $double$, $decimal$, $integer$, $long$, $int$, $short$, $byte$, $nonPositiveInteger$, $negativeInteger$, $nonNegativeInteger$, $positiveInteger$, $unsignedLong$, $unsignedInt$, $unsignedShort$, $unsignedByte$}
    \RETURN $true$
\ELSE
    \RETURN $false$
\ENDIF
\end{algorithmic}
\end{algorithm}

The algorithm iterates through the variable declaration nodes from the prolog and if the variable is explicitly assigned with its type, the type is noted. Otherwise, an attempt of the type deduction of the binding expression is made. The deduction of the type from the expression is presented in Algorithm \ref{ALG_func_determineExpressionType}. On input, it takes an expression node and types of local variables that are valid in the expression (also called context of variables or variable context). The presented algorithm is just shortened illustration since the complete version is too long to be presented in this text. Nevertheless, the principle is straightforward. Depending on the class of the expression node (show in Figure \ref{FIG_syntax_tree_node_types_part_4}), its type can be either determined directly or it depends on its subexpressions. A part of the function's semantic is separated in \ref{ALG_func_determineOperatorType}, which is not presented completely because of the same reason.

Function $determineExpressionType()$ is called within function $analysisOfExpressionTypes$ presented in Algorithm \ref{ALG_func_analysisOfExpressionTypes}, which recursively determines types of all subexpressions. Two important questions about this function emerge. How (in which order) are the tree nodes recursively processed and how does the function handle definitions (bindings) of new variables which may also appear in the expressions?

The order of the recursion is to firstly process children of a node and then the node itself. The order of children processing is specified by function $o$ from the definition of the syntax tree \ref{DEF_syntax_tree}. The reason is that an expression node may need to know types of its subexpressions to determine its own type and we want to determine types of all expressions. Therefore, using the described order, subexpressions of an expression are processed first, and then the expression itself without any need for further recursion, because the types of the subexpressions are already determined.

The handling of new variable definitions relies on the fact that the definitions make the new variables valid only in nodes with a higher sequence number when numbered in the order described in in the previous paragraph. Therefore, the left-most (the first amongst the ordered subnodes) subnode of a certain node can be processed without an extension of the variable context. And, if the left-most subnode extends the variable context for the following nodes in the numbering, it can be easily handled because the types of the new variables can be directly determined since the binding expressions are already processed (thus, their types are known). Every node ''knows'' wheather or not it may define new variables for nodes with higher sequence numbers. This is expressed in the algorithm by the condition stating at line 10. If it does define new variables, they are memorized. Later, upon processing of its parent, they are retrieved and the variable context is extended. This is done at lines 4 and 5. Function $mergeContextVarTypes$ presented in Algorithm \ref{ALG_function_mergeContextVarTypes} writes every record from its second argument (the new variables) into its first argument (the variable context). If there are records for variables with the same names in the context, they are overwritten to correspond to the variable overlapping. It is important to note that we assume the variable context is not passed by reference but by value, and hence, the variable context of a certain node is not affected by the recursive processing of its subnodes.

\begin{algorithm}
\caption{Function analysisOfExpressionTypes}
\label{ALG_func_analysisOfExpressionTypes}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $memorizeType()$: Function memorizing a determined type of a specified node. \\
    $set()$: Function memorizing a specified property of a specified node. \\
    $add()$: Function adding a value to a list of specified properties of a specified node. \\
    $get()$: Function returning a specified property (or list) set by functions $set()$ and $add()$. \\
    $mergeContextVarTypes()$: Function defined in Algorithm \ref{ALG_function_mergeContextVarTypes}. \\
    $startingNode$: A node determining a subtree to perform the analysis on. \\
    $contextVarTypes$: Types of local variables valid in the current subtree.
}

\FORALL{$i \in \{1, \dots, |startingNode.getChildren()|\}$ ordered from the lowest to the highest}
    \STATE $subnode = startingNode.getChild(i)$
    \STATE $analysisOfExpressionTypes(subnode, contextVarTypes)$ \COMMENT{recursion}
    \STATE $newVars = get(subnode, newVars)$    
    \STATE $contextVarTypes = mergeContextVarTypes(contextVarTypes, newVars)$
\ENDFOR
\IF{$is(startingNode, ExprNode)$}
    \STATE $memorizeType(startingNode, determineExpressionType(startingNode))$
\ENDIF
\IF{$is(startingNode, VariableBindingNode)$}
    \STATE $type = null$
    \STATE $typeNode = startingNode.getChild(TypeNode)$
    \IF{$typeNode \neq null$}
        \STATE $type = getTypeTN(typeNode)$
    \ELSE
        \STATE $type = determineExpressionType(startingNode.getChild(BindingSequenceNode).getChild(ExprNode), contextVarTypes)$
    \ENDIF
    \STATE $set(startingNode, newVars, (startingNode.varName, type))$
\ELSIF{$is(startingNode, TupleStreamNode)$}
    \FORALL{$varBindingNode \in startingNode.getChildren()$}
        \STATE $add(startingNode, newVars, get(varBindingNode, newVars))$
    \ENDFOR
\ENDIF
\end{algorithmic}
\end{algorithm}

\todo[inline]{Popisat dvojicu funkcii memorizeType() a getType(). Taktiez trojicu set(), get(), add().}

\todo[inline]{Overit si, ci ALG \ref{ALG_func_analysisOfExpressionTypes} pokryva vsetky pripady, co sa tyka definovania novych premennych a ich propagacie vyssim uzlom.}

\todo[inline]{Pozor na to přetékání textu - na spoustě míst.}

\begin{algorithm}
\caption{Function mergeContextVarTypes}
\label{ALG_function_mergeContextVarTypes}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $keys()$: Function retrieving index values of an indexed structure. \\
    $contextVarTypes$: Types of local variables valid in current context. \\    
    $extendingVarTypes$: New variables in the same structure as the first argument.
}
\ENSURE The context variable types extended with the variable types from the second argument.

\FORALL{$varName \in keys(extendingVarTypes)$}
    \STATE $contextVarTypes[varName] = extendingVarTypes[varName]$
\ENDFOR
\RETURN $contextVarTypes$
\end{algorithmic}
\end{algorithm}

Function $analysisOfExpressionTypes$ called upon a binding expression of a global variable determines the type of the binding expression, and hence, the type of the variable. In case of global variables, the argument $contextVarTypes$ is empty, because there are no local variables valid in the prolog section.

\begin{algorithm}
\caption{Function getVariableType}
\label{ALG_function_get_variable_type}
\begin{algorithmic}[1]
\REQUIRE{\ \\
    $getGlobalVariableType()$: Function returning a determined type of a specified global variable. \\
    $contextVarTypes$: Types of local variables valid in current context. \\
    $var$: A variable to determine the type of.
}
\ENSURE The type of variable $var$.

\IF{$contextVarTypes[var]$ is defined}
     \RETURN $contextVarTypes[var]$
\ELSE
     \RETURN $getGlobalVariableType(var)$
\ENDIF
\end{algorithmic}
\end{algorithm}

The types of processed global variables are available trough function $getGlobalVariableType()$. If the function gets a variable that is not a global one, it returns $null$. Function $getVariableType()$ called in Algorithm \ref{ALG_func_determineExpressionType} is defined in Algorithm \ref{ALG_function_get_variable_type}. It checks if the specified variable is amongst the given local variables. If so, it returns its type, else it handles the variable as a global one and if such global variable does not exist the result is $null$.

\subsection{Determination of Expression Types}
To determine types of expressions, we use already introduced function $analysisOfExpressionTypes$. The starting node (its first argument) is the node representing the query body and the variable context is empty as there cannot be any local variable valid in the body node.

We can also determine expression types in functions. To do this for a certain function, $analysisOfExpressionTypes$ function has to be called with a function declaration node as the starting node. In this case, the function declaration node contains a subnode specifying function's formal arguments. These argument are set as the variable context for the function body represented by another subnode.

\section{Step 3: Inference of Built-in Types}
In this step, the algorithm goes through the syntax tree to infer types of elements and attributes from expressions using the type information from the previous step. These two steps could be merged together but for better comprehension we present it separately.

How are the types inferred from the expression types? We do not exploit all expressions. Only expressions of a particular type are exploited. Specifically, an expression has to contain an subexpression $E$ of $PathType$ type (expression representing a certain element or attribute or set of elements or attributes). In the following text, the set represented by expression $E$ is denoted $S$. Another requirement is that the expression has to be either a function call or an arithmetic operation \todo{Q: Nejake ine ako napr type constructor, cast as? Princip je stale rovnaky. A: ak to jen popište. To je naprosto OK.}.

The output of this step is a set of couples ($pathType$, XML Schema built-in type).

\todo[inline]{Zlucovanie odvodenych tvrdeni.}
\todo[inline]{Path expressions s predikatmi.}

\subsection{Function Calls}
This case is quite straightforward. The algorithm encounters a function call and one of the arguments is a known set of elements of attributes (subexpression $E$ representing $S$). To determine the type of $S$, it is only needed to determine the type of the corresponding formal argument from the definition of the function. The function is either a built-in one so its definition is known or it is defined in the prolog section. External functions are not processed as was mentioned already.

If the type $T$ of the formal argument is a built-in type or its sequence, then $T$ is also the inferred type of $S$. Otherwise, no statement is inferred.

\subsection{Arithmetic Operations}
If the operator is one of $+$, $-$, $*$, $div$, $mod$ (the class of the expression node is $Operator$ and it represents one of $PLUS$, $MINUS$, $MUL$, $DIV$, $MOD$ \todo{Niekam napisat mozne triedy operatora}), one operand is $E$ and the type $T$ of the other operand is one of numeric built-in types, then $T$ is also the inferred type of $S$.

If the operator is one of $<$, $>$, $<=$, $>=$, $=$, $!=$ (the class of the expression node is $Operator$ and it represents one of $GEN\_LESS\_THAN$, $GEN\_GREATER\_THAN$, $GEN\_LESS\_THAN\_EQUALS$, $GEN\_GREATER\_THAN\_EQUALS$, $GEN\_EQUALS$, $GEN\_NOT\_EQUALS$), one operand is $E$ and the type $T$ of the other operand is one of built-in types, then $T$ is also the inferred type of $S$.

\todo[inline]{Pěkné, neškodilo by proložit příklady, tj. dotaz, strom, co z něho odvodíme.}