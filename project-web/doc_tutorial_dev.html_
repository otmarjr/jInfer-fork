#include "header.html_"

<!-- TODO link to architecture, inference etc. articles --!>

<div id="content">
	<h1>Module Developer's Tutorial</h1>

        <p>
          Target audience: jInfer module developers. Anyone who needs to extend jInfer capabilities by writing a new module.
        </p>
        <p>
          <span class="prerequisities">
            This tutorial assumes that you are a seasoned Java developer. Having experience with programming in some kind of framework (NetBeans Platform above all) will help you a lot.<br/>
            Make sure you have read the <a href="architecture.pdf">article</a> on architecture, data structures and inference process to understand what you will be implementing.<br/>
            Also, before starting this tutorial, make sure you can <a href="building_jinfer.html">build jInfer from sources</a>.
          </span>
        </p>

<h2>Overview</h2>
  <ol type=1>
    <li><a href="#1-get-jinfer">Get NetBeans, jInfer sources, try a build.</a></li>
    <li><a href="#2-module-type">Decide on the type of module you want to create.</a></li>
    <li><a href="#3-new-module">Create new NetBeans module.</a></li>
    <li><a href="#4-implement-jinfer">Implement jInfer-specific interfaces.</a></li>
    <li><a href="#5-implement-logic">Implement your logic.</a></li>
  </ol>

<h2 id="1-get-jinfer">Building jInfer from sources</h2>
  <p>
    Refer to the <a href="building_jinfer.html">official instructions</a>.
  </p>

<h2 id="2-module-type">What type of module?</h2>
  <p>
    First thing you need to realize is what kind of module you will be
    implementing. Is it going to be a part of the inference? If yes, what stage?
    Importing the initial grammar? Simplifying it? Exporting to resulting schema?
    If you are not sure what these terms mean, go read the articles on interence process again.
  </p>
  <p>
    If your logic doesn't belong to the inference process, it might just extend
    one of the existing modules. Try looking for the code you would like to change.
  </p>

<h2 id="3-new-module">New NetBeans module</h2>
<p>
  <span class="prerequisities">This section assumes you have successfully imported jInfer in NetBeans.</span>
</p>
<ol type=1>
  <li>Expand the jInfer suite (brown puzzles icon).</li>
  <li>Right-click <i>Modules</i>, select <i>Add New...</i>.</li>
  <li>On the first page, pick a name for your module. Click <i>Next</i>.</li>
  <li>On the second page, fill out the following:
    <ul>
      <li>
        <i>Code base</i>: this will be the package structure in which your code is placed.
        If you want, follow our convention: <code>cz.cuni.mff.ksi.jinfer.<i>yourmodule</i></code>.
        Otherwise choose something like <code><i>tld.company.jinfer.yourmodule</i></code>.
      </li>
      <li><i>Module display name</i>: pretty obvious.</li>
      <li><i>Generate XML layer</i>: you may want to check this option, but it doesn't really matter at this stage.</li>
    </ul>
    Rest of the options is uninteresting in most cases.
  </li>
  <li>Click <i>Finish</i>.</li>
</ol>

<h2 id="4-implement-jinfer">Implement jInfer's specifics</h2>

<p>
This section will show how to deal with a new inference module - a simplifier
that does no actual simplification, just returns the grammar it got on input.
Your module will need a "main" class implementing the chosen inference
interface, annotated with a <code>@ServiceProvider</code> annotation.
</p>

<p>
But first, we need to do some setup.

<ol type=1>
  <li>Right-click the newly created module, select <i>Properties</i>.</li>
  <li>In <i>Libraries &gt; Module Dependencies</i>, click <i>Add Dependency...</i>.</li>
  <li>Filter for "base" and select <i>Base</i> as a dependency. Click <i>OK</i>.</li>
  <li>
      Still in <i>Properties</i>, switch to <i>Display</i> category. Fill in:
      <ul>
        <li><i>Display Name</i>: Fill in a user-friendly name of your module.</li>
        <li><i>Display Category</i>: type in <i>jInfer</i>.</li>
        <li><i>Short &amp; Long Description</i>: unleash your inner poet!</li>
      </ul>
  </li>
  <li>Still in <i>Properties</i>, switch to <i>API Versioning</i>.</li>
  <li>Type <code>cz.cuni.mff.ksi.jinfer.base.interfaces.inference.Simplifier</code> in <i>Provided Tokens</i>.</li>
  <li>Close <i>Properties</i> by clicking <i>OK</i>.</li>
</ol>
</p>

<p>
Now to the class itself.

<ol type=1>
  <li>Add a new Java class: right click <i>Source Packages</i> in your new
      module, select <i>New &gt; Java Class...</i>.</li>
  <li>Fill in class name, for example <i>MySimplifierImpl</i>.</li>
  <li>Fill in package based on the <i>Code base</i> you selected while creating
      the module itself.</li>
  <li>Click <i>Finish</i>.</li>
  <li>In the heading line of the class, add <code>implements Simplifier</code> and
      fix the imports (you need <code>Simplifier</code> from Base module).</li>
  <li>Annotate this class with <code>@ServiceProvider(service = Simplifier.class)</code>.</li>
  <li>NetBeans will complain about missing method implementations, add them.</li>
  <li>
    Now fill in method bodies:
    <ul>
      <li><code>getName()</code>: return a string with module unix name, for example <code>"mysimplifier"</code>.</li>
      <li><code>getDisplayName()</code>: return a user friendly module name, for example <code>"My First Simplifier"</code>.</li>
      <li><code>getModuleDescription()</code>: return a short module description. You can also return <code>getDisplayName()</code> in this case.</li>
      <li><code>getCapabilities()</code>: for the moment, it is enough to return <code>Collections.emptyList()</code>.</li>
      <li><code>start()</code>: here is where your main logic belongs. In the case of a simplifier, you would do something with the rules and return a simplified grammar. For now, just do <code>callback.finished(initialGrammar);</code></li>
    </ul>
  </li>
</ol>
</p>

<h2>Run jInfer</h2>

<p>
  At this moment, run the whole jInfer suite from the NetBeans you imported it into.
  A new, child NetBeans should open with your module correctly installed. You can
  now follow the <a href="doc_tutorial.html">User tutorial</a>, just select your new
  simplifier while creating a new jInfer project.<br/>
  That's it! Start hacking you logic now!
</p>

<h2 id="5-implement-logic">Implement your logic</h2>

<p>
  This is the part where you actually have to do some thinking :-) Implementing
  an importer? Take that <code>InputStream</code> and create some rules of it! Simplifier?
  Take the rules you got and compact them somehow! Exporter? Take those rules and
  write them out as a <code>String</code>! It only depends on which module you are
  in and algorithm you're implementing.
</p>

<h2>Dealing with jInfer and NetBeans Platform</h2>

<p>
  This section deals with a few important but pretty specific parts of interface
  between your module (or any logic you implement) and either jInfer or NetBeans
  Platform. Not nearly everything regarding interaction with NBP is mentioned here,
  please refer to the relevant FAQ.
</p>

<h3>Module visibility</h3>

<p>
Each NBP module allows to set packages as public, which means their content will be visible for another modules. That means, if some module A sets
a dependency for module B, module A will be able to use only classes from packages, which were set as public in module B.
</p>
<span><i><strong>Important notice:</strong> Public packages do not affect <a href="http://wiki.netbeans.org/DevFaqLookup">Lookup</a> mechanism i.e. class annotated with serviceProvider may not be in the public package.</i></span>
<p>
There are two ways to set visible packages, first is to set it manually in module's project.xml file located in <i>ModulePath/nbproject/</i> folder.
</p>
<span>Example:</span><br/>
<pre class="code">
// This is a portion of example project.xml file.
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://www.netbeans.org/ns/project/1"&gt;
    &lt;type&gt;org.netbeans.modules.apisupport.project&lt;/type&gt;
    &lt;configuration&gt;
        &lt;data xmlns="http://www.netbeans.org/ns/nb-module-project/3"&gt;

            ....

            &lt;public-packages&gt;
                &lt;package&gt;some.example.package.name&lt;/package&gt;
            &lt;/public-packages&gt;
        &lt;/data&gt;
    &lt;/configuration&gt;
&lt;/project&gt;
</pre>

<p>
Another way is to set public packages through GUI:

<ol type=1>
	<li>Right-click the module, select <i>Properties</i>.</li>
	<li>In <i>API Versioning</i>, there is <i>Public Packages</i> section.</li>
	<li>Check which package will be public.</li>
</ol>

</p>
<h3>Error handling</h3>

<p>
Each run of inference is encapsulated in a <code>try-catch</code> block, so it is safe to throw any exception in inference process.
Each thrown exception will be catched, get logged, presented to the user and inference will stop. However if module uses threads which
throw exception, it is catched by NBP, instead of our code. Because of this is reasonable to catch this exception in your module and re-throw it in the right thread.
</p>

<h3>Interruptions</h3>

<p>
In our application, we gave user an ability to stop inference in any moment of its run. For this reason, modules have to check in every time-consuming place
such as long loops, if this case happens. Example below shows, how to check the interruption from user and what to do to correctly stop inference.
</p>
<span>Example:</span>
<pre class="code">
for (forever) {
    if (Thread.interrupted()) {
        throw new InterruptedException();
    }
    doStuff();
}

</pre>

<h3>Dialogs</h3>

<p>
  Creation of open/save dialog or message window is done by standard NBP API.
  For dialogs you can also use standard Java JFileChooser,
  but NBP <a href="http://bits.netbeans.org/dev/javadoc/org-openide-filesystems/org/openide/filesystems/FileChooserBuilder.html">FileChooserBuilder</a>
  is more convenient. This class creates dialog which remembers last-used directory according to key passed into its contructor.
</p>
<span>Example:</span><br/>
<pre class="code">
// The default dir to use if no value is stored
File home = new File (System.getProperty("user.home"));
// Now build a file chooser and invoke the dialog in one line of code
File toAdd = new FileChooserBuilder (CallingClass.class)
                   .setTitle("Some dialog title")
                   .setDefaultWorkingDirectory(home).showOpenDialog();
// Result will be null if the user clicked cancel or closed the dialog w/o OK
if (toAdd != null) {
    //do something
}
</pre>
<p>
  For messages creation is used <a href="http://bits.netbeans.org/dev/javadoc/org-openide-dialogs/org/openide/DialogDisplayer.html">DialogDisplayer</a> NBP API
  class. To determine which type of message will be shown (Confirmation dialog, message dialog...),
  <a href="http://bits.netbeans.org/dev/javadoc/org-openide-dialogs/org/openide/NotifyDescriptor.html">NotifyDescriptor</a> is used.
  Below is small example, which creates standard message notification. For more information please look at <a href="http://wiki.netbeans.org/NetBeansDeveloperFAQ#Dialogs_API">NBP Dialogs API FAQ</a>.
</p>
<span>Example:</span><br/>
<pre class="code">
// Creates standard information message with text "Hello world"
NotifyDescriptor nd = new NotifyDescriptor
                            .Message("Hello world",
                               NotifyDescriptor.INFORMATION_MESSAGE);
DialogDisplayer.getDefault().notify(nd);
</pre>

<h3>Configuration - options, preferences</h3>

<p>
Option panels located in <i>Tools > Options</i> menu are standard part of NBP API. We created for our purpose jInfer option subCategory
where are located Preferences applied for each jInfer Project. Below are described few step to create
your own option panel. For more information, please visit <a href="http://platform.netbeans.org/tutorials/60/nbm-options.html">NetBeans Options tutorial</a>.
</p>
<ol>
	<li>Create options window:
		<ul>
			<li>Right click <i>Source Packages</i> in your module, select <i>New &gt; Other</i>.</li>
			<li>Under Categories, select Module Development. Under File Types, select Options Panel. Click <i>Next</i>.</li>
			<li>Keep checked <i>Create Secondary Panel</i> and choose jInfer as a <i>Primary Panel</i>. Fill in remaining fields. Click <i>Next</i>.
			</li>
			<li>Fill in <i>Class Name Prefix</i> and <i>Package</i> and click <i>Finish</i>.</li>
		</ul>
	</li>
	<li>Design newly created <i>ClassNamePrexix</i>Panel.java.</li>
	<li>Implement <code>store()</code> and <code>load()</code> methods according to comments inside.</li>
</ol>
<p>
Both <code>store()</code> and <code>load()</code> methods uses <a href="http://bits.netbeans.org/dev/javadoc/org-openide-util/org/openide/util/NbPreferences.html">NbPreferences</a> class. Example below shows how to store and load Preferences.
</p>
<span>Example:</span><br/>
<pre class="code">
public void store() {
    // Saves state of checkBox into Preferences for ExampleClass
    //Class in Property with name "PropertyName".
    NbPreferences.forModule(ExampleClass.class)
        .putBoolean("PropertyName", someCheckBox.isSelected());
}

public void load() {
    // Get from ExampleClass Class Preferences Property with name
    // "PropertyName". Second parameter of method getBoolean is used
    // as default if no Property with defined name is saved in Preferences.
    someCheckBox.setSelected(NbPreferences.forModule(ExampleClass.class)
                                 .getBoolean("PropertyName", true));
}
</pre>

<p>
Second type of preferences used in jInfer is Project properties. Each jInfer Project has its properties panel accessible
in its content menu and preferences set in this properties are applied for each project separately. To implement this kind of
preferences, it is necessary to implement <a href="http://jinfer.sourceforge.net/javadoc/cz/cuni/mff/ksi/jinfer/base/interfaces/PropertiesPanelProvider.html">PropertiesPanelProvider</a> interface and extend <a href="http://jinfer.sourceforge.net/javadoc/cz/cuni/mff/ksi/jinfer/base/objects/AbstractPropertiesPanel.html">AbstractPropertiesPanel</a> class. Each Project properties window has category tree, where each category represents separate panel with properties. This category is definded by provider interface, and properties panel by class extended AbstractPropertiesPanel.
</p>
<h4>PropertiesPanelProvider</h4>
<p>As was written above, PropertiesPanelProvider defines category in Project properties windows. In the example below, we'll try to explain how to create a simple provider and what each method is responsible for.</p>
<span>Example:</span><br/>
<pre class="code">
public class ExampleProvider implemenets PropertiesPanelProvider {

  // Get Providers programmatic name or Id.
  public String getName() {
    return "ExampleProvider";
  }

  // This name will be displayed in category tree.
  public String getDisplayName() {
    return "Example Category";
  }

  // Priority of category. Higher the number, higher
  // will be category in tree. If two categories have
  // same priorities, they are sorted according
  // to their names.
  public int getPriority() {
    return 0;
  }

  // Returns properties panel defined for this category.
  public AbstractPropertiesPanel getPanel(final Properties properties) {
    return new ExamplePropertiesPanel(properties);
  }

  // Defines parent category of this category. If return null, this is top
  // level category. In other cases id of parent category must be returned.
  public String getParent() {
    return null;
  }

  // Optional. For each category can be defined list of virtual categories
  // which shows instead of properties panel only panel with information,
  // how many and for what kind of modules categories contains
  // this virtual category.
  public List<VirtualCategoryPanel> getSubCategories() {
    return null;
  }
}
</pre>
<h4>AbstractPropertiesPanel</h4>
<p>
This class represents visual component of properties category. You can design it in whatever way you like. For proper functionality must be fullfiled these few steps:
</p>
<ol>
	<li>Call <code>super(Properties)</code> in constructor: By this step is Properties instance saved into <code>properties</code> protected
		field and you can use it in <code>load()</code> and <code>store()</code> methods.</li>
	<li>Implement <code>load()</code> method: In this method are values, previously saved into Properties instance provided to this panel, loaded into
		components to be founded in this panel.</li>
	<li>Implement <code>store()</code> method: Here are values gathered from components of this panel saved into Properties.</li>
</ol>

<span>Example:</span><br/>
<pre class="code">
// This is only a part of
public abstract class ExamplePanel extends AbstractPropertiesPanel {

  public ExamplePanel(final Properties properties) {
    super(properties);
  }

  public abstract void store() {
    properties.setProperty("exampleKey", someTextField.getText());
  }

  public abstract void load() {
    String propValue = properties.getProperty("exampleKey", "");
    someTextField.setText(propValue);
  }

}
</pre>

<h3>Rule display</h3>

<p>
Rule displayer is component used for visualisation of rules in any part of inference process, but mainly in simplification part.
If provided rule displayers are not good enough or something is missing, you can implement rule displayer for your own.
You just need to follow these few easy steps:
</p>
<ol type=1>
	<li>Implement <code>cz.cuni.mff.ksi.jinfer.base.interfaces.RuleDisplayer</code>
		<ul>
			<li><code>RuleDisplayer</code> interface extends <code>NamedModule</code>, so you need to override its methods.</li>
			<li>Override <code>createDisplayer(name, rules)</code> method which creates displayer window responsible for displaying rules.</li>
		</ul>
	</li>
	<li>Annotate this class with <code>@ServiceProvider(service = RuleDisplayer.class)</code></li>
</ol>

<span>Example:</span><br/>
<pre class="code">
@ServiceProvider(service = RuleDisplayer.class)
public final class ExampleRuleDisplayer implements RuleDisplayer {

  @Override
  public void createDisplayer(final String panelName, final List<Element> rules) {
    // Creates standard NBP TopComponent in which are rules displayed.
    ExampleRDTopComp topComponent = ExampleRDTopComp.findInstance();
    if (!topComponent.isOpened()) {
      topComponent.open();
    }
    topComponent.createRuleDisplayer(panelName, rules);
  }

  @Override
  public String getName() {
    return "displayerID";
  }

  @Override
  public String getDisplayName() {
    return "Example rule displayer";
  }

  @Override
  public String getModuleDescription() {
    return getDisplayName();
  }
}
</pre>

<h3>Console output, logging</h3>

<p>
For printing data to console output, NBP provides <a href="http://bits.netbeans.org/dev/javadoc/org-openide-io/org/openide/windows/IOProvider.html">IOProvider</a> and <a href="http://bits.netbeans.org/dev/javadoc/org-openide-io/org/openide/windows/InputOutput.html">InputOutput</a> classes.
IOProvider's method <code>getIO(String, boolean)</code> returns InputOutput instance, which can be used to obtain Reader/OutputWriter to read/write into output window.
</p>
<span>Example:</span><br/>
<pre class="code">
// Creates new output window, where first parameter is a name and second
// is flag determinig if new window will be created if there is already
// a window with the same name.
final InputOutput ioResult = IOProvider.getDefault().getIO("Example", true);
ioResult.getOut().println("Hello world");

// After writing everything into output window close the output.
ioResult.getOut().close();
</pre>

<p>
Logging is done in jInfer by using <a href="http://logging.apache.org/log4j/1.2/">Log4j tool</a>. If you are not familiar with
Log4j, example below show you some simple usage. All logged messages are saved in a standard log file placed
in <i>UserHome/.jinfer/</i> folder and printed into "jInfer" output window in jInfer application. For each of these two places can be set
in jInfer options, for which LOG level will be messages saved/printed.
</p>
<span>Example:<span><br/>
<pre class="code">
// Creates Logger instance for particular class
private static final Logger LOG = Logger.getLogger(Example.class);

    ...

// Log a message with info level
LOG.info("Some message with info log level");
</pre>

<h3>RunningProject class</h3>

TODO

<h3>Properties ComboBox</h3>

TODO

</div>

#include "footer.html_"
