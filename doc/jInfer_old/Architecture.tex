\documentclass[10pt,a4paper,notitlepage]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\begin{document}

\title{jInfer Architecture} 
\author{Matej Vitásek} 
\maketitle 

The description of jInfer architecture will commence by describing the data structures, namely representations of regular expressions and XML elements, attributes and simple data.\\

Afterwards the interfaces of basic inference modules - Initial Grammar Generator, Simplifier and Schema Generator - will be explained.\\

Finally, the process of inference will be described.

\subsection{Package naming conventions}

All packages start with \texttt{cz.cuni.mff.ksi.jinfer}. Afterwards is the short, normalized name of the module (e.g. \texttt{base}) and finally the package structure in this module (e.g. \texttt{objects.utils}). All in all, a package in the Base module could look like 
\begin{verbatim}
cz.cuni.mff.ksi.jinfer.base.objects.utils
\end{verbatim}

\section{Data structures}

\subsection{Regular expressions}

For general information on regular expressions, please refer for example to Wikipedia: $http://en.wikipedia.org/wiki/Regular\_expression$ .\\

All classes pertaining to regular expressions can be found in the package \texttt{cz.cuni.mff.ksi.jinfer.base.regexp}.\\

In jInfer, the following types of regular expressions are represented:
\begin{itemize}
	\item Token - a letter of the language described by this regular expression. In this case, an \texttt{AbstractNode} (see \ref{xml-rep}). Eg. \textit{"a"}.
	\item Concatenation - one or more regular expression in an ordered sequence. Eg. \textit{"(a, b, c, d)"}.
	\item Alternation - a choice between one or more regular expressions. Eg. \textit{"(a $|$ b $|$ c $|$ d)"}.
	\item Kleene star ("*") - a regular expression that can occur any number times (zero to infinity) in a row. Eg. \textit{"a*"}.
\end{itemize}

These types are defined in the \texttt{RegexpType} enum as \texttt{TOKEN}, \texttt{CONCATENATION}, \texttt{ALTERNATION} and \texttt{KLEENE}.\\

The class representing a regular expression is \texttt{Regexp}. A \texttt{Regexp} is a generic class (let's denominate its type variable as \textit{T}) that has three main members:
\begin{itemize}
	\item \texttt{type} - a \texttt{RegexpType} instance, set in the constructor and immutable afterwards. Can be queried via the method \texttt{getType()} or shorthand boolean methods
	\begin{itemize}
		\item \texttt{isToken()}
		\item \texttt{isConcatenation()}
		\item \texttt{isAlternation()}
		\item \texttt{isKleene()}
	\end{itemize}
	
	\item \texttt{content} - a type \textit{T} member. Must be set iff the \texttt{type} is \texttt{TOKEN}, \texttt{null} otherwise. Means "the token represented by this regular expression". % TODO how to query
	
	\item \texttt{children} - a list of \texttt{Regexp}s of the type \textit{T}. Must be set iff the \texttt{type} is \textbf{not} \texttt{TOKEN}, \texttt{null} otherwise. If the \texttt{type} is \texttt{KLEENE}, it must contain exactly one element, although this rule is not enforced by the code. Otherwise the number of elements in this list is unconstrained. The meaning of this member is "the list of regular sub-expressions in this concatenation / alternation / Kleene star". % TODO how to query
\end{itemize}

\textit{Example:} regular expression \textit{"(a, b, (c $|$ d))*"} would be represented as a \texttt{Regexp} of type \texttt{KLEENE} with children of size 1, containing a \texttt{CONCATENATION} with 3 children. Of these three, the first two would be \texttt{TOKEN}s with content \textit{"a"} and \textit{"b"} respectively. The last child would be an \texttt{ALTERNATION} containing two \texttt{TOKEN}s \textit{"c"} and \textit{"d"}. It is obvious that this representation of regular expressions creates tree structures.

\subsection{XML representation}
\label{xml-rep}

The classes that represent XML elements, attributes and simple text data (collectively known as \textit{XML nodes}) are summarized in figure \ref{img-arch-nodes}.

\begin{figure}
	\includegraphics[scale=0.3]{Architecture-images/nodes.eps} 
	\caption{UML class diagram of classes representing XML nodes}
	\label{img-arch-nodes}
\end{figure}

It is important to note that attributes in jInfer's data structures are nodes too, just like elements and simple data.\\

Description of all classes from the schema follows. All classes can be found in \texttt{cz.cuni.mff.ksi.jinfer.base.objects} package.

\subsubsection{\texttt{NodeType}}

NodeType is an enum of all non-abstract node types, i.e. ATTRIBUTE, ELEMENT, SIMPLE\_DATA.

\subsubsection{\texttt{AbstractNode}}

A common ancestor of all XML nodes. Contains the following members:
\begin{itemize}
	\item \texttt{context} - a list of \texttt{String}s, element names, marking the path from this document's root element to the current node. For example, in a document like this
\begin{verbatim}
<people>
<person>
<name first="John" last="Doe">
</person>
</people>
\end{verbatim} % TODO tabs
the element \texttt{$<$name$>$} would have context \texttt{\{"people", "person"\}} while the element \texttt{$<$people$>$} would have an empty list for context.
	\item \texttt{name} - a String representing this node's name. For \texttt{ELEMENT}s and \texttt{ATTRIBUTES}s this is their name. For \texttt{SIMPLE\_DATA}, this is the string representation of the textual data in this node.
	\item \texttt{metadata} - a map indexed by \texttt{String}s, containing general \texttt{Object}s containing various metadata related to this node. At this moment, three types of metadata are recognized:
	\begin{itemize}
		\item required - used in \texttt{ATTRIBUTE}s. If there is a \texttt{Boolean.TRUE} value under this key in metadata, it means that the attribute represented by this node is considered to be required (for example, in DTD this would be marked as \texttt{\#REQUIRED}).
		\item \texttt{from.schema} - a \texttt{Boolean.TRUE} value under this key means that this node was obtained while processing an XML schema.
		\item \texttt{from.query} - a \texttt{Boolean.TRUE} value under this key means that this node was obtained while processing a query.
	\end{itemize}
	jInfer module are free to ignore or process these metadata.
\end{itemize}
Method \texttt{getType()} returning this node's \texttt{NodeType} is declared as abstract and overriden in corresponding classes.

\subsubsection{\texttt{Element}}

Represents an actual XML element. Apart from the members mentioned before, a new member \texttt{subnodes} is introduced. \texttt{subnodes} is of type \texttt{Regexp$<$AbstractNodes$>$}. This regular expression describes the allowed content of this node (i.e. the nodes that can be within, hence \textit{subnodes}). \texttt{subnodes} may be \texttt{null}.

\subsubsection{\texttt{AbstractContentNode}}

A common ancestor for nodes that have some (usually textual) content. This class is generic, however, this document assumes it to be parametrized as \texttt{AbstractContentNode$<$String$>$} for the sake of simplicity. Contains the following members:
\begin{itemize}
	\item \texttt{contentType} - a \texttt{String} describing the type of the content in this node. Note that the parameter is currently ignored and will probably be deleted or changed.
	\item \texttt{content} - a list of \texttt{String}s holding the actual content of this node. Note that a single node has only one string as its content, however, as the nodes are routinely aggregated, this list might hold all the contents of the original aggregated nodes.
\end{itemize}

\subsubsection{\texttt{Attribute}}

This is just a marker implementation of an \texttt{AbstractContentNode$<$String$>$}. Represents an XML attribute.

\subsubsection{\texttt{SimpleData}}

This is just a marker implementation of an \texttt{AbstractContentNode$<$String$>$}. Represents XML simple text data.

\section{Interfaces}

\section{Inference process}

\end{document}